

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bfit &mdash; BFit  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> BFit
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BFit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/autoapi/bfit/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="module-bfit">
<span id="bfit"></span><h1><a class="reference internal" href="#module-bfit" title="bfit"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit</span></code></a><a class="headerlink" href="#module-bfit" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="greedy/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.greedy</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="greedy/greedy_kl/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.greedy.greedy_kl</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy/greedy_lq/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.greedy.greedy_lq</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy/greedy_strat/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.greedy.greedy_strat</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy/greedy_utils/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.greedy.greedy_utils</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="greedy/optimize/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.greedy.optimize</span></code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="_slater/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit._slater</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="density/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.density</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="fit/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.fit</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="grid/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.grid</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="measure/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.measure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="model/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.model</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="parse_ugbs/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.parse_ugbs</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.KLDivergenceSCF" title="bfit.KLDivergenceSCF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KLDivergenceSCF</span></code></a></p></td>
<td><p>Kullback-Leiber Divergence Self-Consistent Fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.GaussianBasisFit" title="bfit.GaussianBasisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GaussianBasisFit</span></code></a></p></td>
<td><p>Optimizes either least-squares or Kullback-Leibler of Gaussian funcs using <cite>Scipy.optimize</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.ClenshawRadialGrid" title="bfit.ClenshawRadialGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClenshawRadialGrid</span></code></a></p></td>
<td><p>Clenshaw-Curtis Radial Grid Class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.UniformRadialGrid" title="bfit.UniformRadialGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UniformRadialGrid</span></code></a></p></td>
<td><p>Uniformly Distributed Radial Grid Class.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.CubicGrid" title="bfit.CubicGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CubicGrid</span></code></a></p></td>
<td><p>Equally-Spaced 3D Cubic Grid Class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.AtomicGaussianDensity" title="bfit.AtomicGaussianDensity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AtomicGaussianDensity</span></code></a></p></td>
<td><p>Gaussian density model for modeling the electronic density of a single atom.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.MolecularGaussianDensity" title="bfit.MolecularGaussianDensity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MolecularGaussianDensity</span></code></a></p></td>
<td><p>Molecular Atom-Centered Gaussian Density Model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.AtomicDensity" title="bfit.AtomicDensity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AtomicDensity</span></code></a></p></td>
<td><p>Atomic Density Class.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.KLDivergence" title="bfit.KLDivergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KLDivergence</span></code></a></p></td>
<td><p>Kullback-Leibler Divergence Class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.SquaredDifference" title="bfit.SquaredDifference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SquaredDifference</span></code></a></p></td>
<td><p>Squared Difference Class for performing the Least-Squared method.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.GreedyStrategy" title="bfit.GreedyStrategy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GreedyStrategy</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.GreedyKL" title="bfit.GreedyKL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GreedyKL</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.GreedyLeastSquares" title="bfit.GreedyLeastSquares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GreedyLeastSquares</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="bfit.KLDivergenceSCF">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">KLDivergenceSCF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span></em>, <em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">mask_value</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">integration_val</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/fit.html#KLDivergenceSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.KLDivergenceSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_BaseFit</span></code></p>
<p>Kullback-Leiber Divergence Self-Consistent Fitting.</p>
<p>Optimizes the coefficients and exponents of the Gaussian Model to a function using the
Kullback-Leibler divergence measure with the constraint that it is normalized.</p>
<dl class="py attribute">
<dt id="bfit.KLDivergenceSCF.grid">
<code class="sig-name descname">grid</code><a class="headerlink" href="#bfit.KLDivergenceSCF.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid class that contains the grid points and integration methods on them.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(_BaseRadialGrid, <a class="reference internal" href="grid/index.html#bfit.grid.CubicGrid" title="bfit.grid.CubicGrid">CubicGrid</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.KLDivergenceSCF.density">
<code class="sig-name descname">density</code><a class="headerlink" href="#bfit.KLDivergenceSCF.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The true function evaluated on the grid points from <cite>grid</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.KLDivergenceSCF.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#bfit.KLDivergenceSCF.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The Gaussian basis model density. Located in <cite>model.py</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#bfit.AtomicGaussianDensity" title="bfit.AtomicGaussianDensity">AtomicGaussianDensity</a>, <a class="reference internal" href="#bfit.MolecularGaussianDensity" title="bfit.MolecularGaussianDensity">MolecularGaussianDensity</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.KLDivergenceSCF.measure">
<code class="sig-name descname">measure</code><a class="headerlink" href="#bfit.KLDivergenceSCF.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>The deviation measure between true density and model density. Located in <cite>measure.py</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#bfit.SquaredDifference" title="bfit.SquaredDifference">SquaredDifference</a>, <a class="reference internal" href="#bfit.KLDivergence" title="bfit.KLDivergence">KLDivergence</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.KLDivergenceSCF.norm">
<code class="sig-name descname">norm</code><a class="headerlink" href="#bfit.KLDivergenceSCF.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>The integral of the attribute <cite>density</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.KLDivergenceSCF.lagrange_multiplier">
<code class="sig-name descname">lagrange_multiplier</code><a class="headerlink" href="#bfit.KLDivergenceSCF.lagrange_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Lagrange multiplier.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">run(): dict</code></dt>
<dd><p>Runs the optimizing algorithm for optimizing coefficients and exponents to a linear
combination of Gaussian functions.</p>
</dd></dl>

<p class="rubric">Examples</p>
<p>The goal is to fit a Gaussian density to some function.
def f(x) :</p>
<blockquote>
<div><p># Insert what it does here.
return …</p>
</div></blockquote>
<p>The first step is to define the grid object.
&gt;&gt; grid = CubicGrid(0.01, 0.99, 0.01)</p>
<p>Place the values of <cite>f</cite> on those grid points in an array.
&gt;&gt; density = f(grid.points)</p>
<p>Define the model, that you want to fit with.
&gt;&gt; model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)</p>
<p>Define which algorithm you want to optmize.
&gt;&gt; fit = KLDivergenceSCF(grid, density, model)</p>
<p>Optimize the coefficients and exponents but give an initial guess.
&gt;&gt; initc = [1.] * 10
&gt;&gt; inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
&gt;&gt; result = fit.run(initc, inite)</p>
<p>Print out the results.
&gt;&gt; print(“Optimized coefficients are: “, result[“x”][0])
&gt;&gt; print(“Optimized exponents are: “, result[“x”][1])
&gt;&gt; print(“Final performance measures are: “, result[“performance”][-1])
&gt;&gt; print(“Was it successful? “, result[“success”])</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The algorithm uses masked value for floating point precision. This is due to the division found</p></li>
</ul>
<p>in the Kullback-Leibler formula. It is recommended to use <cite>np.float64</cite> or <cite>np.float128</cite> when
storing the arrays. A higher Mask value will work as well but may cause poor precision.
Alternatively, a well-chosen grid and/or initial guesses will avoid overflow/underflow
floating-point issues.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] BFit: Information-Theoretic Approach to Basis-Set Fitting of Electron Densities</dt><dd><dl class="simple">
<dt>Alireza Tehrani, Farnaz Heidar-Zadeh, James S. M. Anderson, Toon Verstraelen, and</dt><dd><p>TODO Add more authors if needed … Paul W. Ayers.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="id0">
<em class="property">property </em><code class="sig-name descname">lagrange_multiplier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the lagrange multiplier.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.KLDivergenceSCF._update_params">
<code class="sig-name descname">_update_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">expons</span></em>, <em class="sig-param"><span class="n">update_coeffs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">update_expons</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.KLDivergenceSCF._update_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute updated coefficients &amp; exponents of Gaussian basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (<em>ndarray</em>) – The initial coefficients of Gaussian basis functions.</p></li>
<li><p><strong>expons</strong> (<em>ndarray</em>) – The initial exponents of Gaussian basis functions.</p></li>
<li><p><strong>update_coeffs</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize coefficients of Gaussian basis functions.</p></li>
<li><p><strong>update_expons</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize exponents of Gaussian basis functions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>coeffs</strong> (<em>ndarray</em>) – The updated coefficients of Gaussian basis functions. Only returned if <cite>deriv=True</cite>.</p></li>
<li><p><strong>expons</strong> (<em>ndarray</em>) – The updated exponents of Gaussian basis functions. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.KLDivergenceSCF.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">c0</span></em>, <em class="sig-param"><span class="n">e0</span></em>, <em class="sig-param"><span class="n">opt_coeffs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">opt_expons</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">c_threshold</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">e_threshold</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">d_threshold</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.KLDivergenceSCF.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the coefficients &amp; exponents of Gaussian basis functions self-consistently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c0</strong> (<em>ndarray</em>) – The initial coefficients of Gaussian basis functions.</p></li>
<li><p><strong>e0</strong> (<em>ndarray</em>) – The initial exponents of Gaussian basis functions.</p></li>
<li><p><strong>opt_coeffs</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize coefficients of Gaussian basis functions.</p></li>
<li><p><strong>opt_expons</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize exponents of Gaussian basis functions.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations.</p></li>
<li><p><strong>c_threshold</strong> (<em>float</em>) – The convergence threshold for absolute change in coefficients. Default is 1e-6.</p></li>
<li><p><strong>e_threshold</strong> (<em>float</em>) – The convergence threshold for absolute change in exponents. Default is 1e-6.</p></li>
<li><p><strong>d_threshold</strong> (<em>float</em>) – The convergence threshold for absolute change in divergence value. Default is 1e-6.</p></li>
<li><p><strong>disp</strong> (<em>bool</em>) – If true, then at each iteration the integral, <span class="math notranslate nohighlight">\(L_1\)</span>, <span class="math notranslate nohighlight">\(L_\infty\)</span> and
Kullback-Leibler measure is printed. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> – The optimization results presented as a dictionary containing:
“x” : (ndarray, ndarray)</p>
<blockquote>
<div><p>The optimized coefficients and exponents.</p>
</div></blockquote>
<dl class="simple">
<dt>”success”: bool</dt><dd><p>Whether or not the optimization exited successfully.</p>
</dd>
<dt>”fun”<span class="classifier">ndarray</span></dt><dd><p>Values of KL divergence (objective function) at each iteration.</p>
</dd>
<dt>”performance”<span class="classifier">ndarray</span></dt><dd><p>Values of various performance measures of modeled density at each iteration,
as computed by <cite>goodness_of_fit()</cite> method.</p>
</dd>
<dt>”time”<span class="classifier">float</span></dt><dd><p>The time in seconds it took to complete the algorithm.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.GaussianBasisFit">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">GaussianBasisFit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span></em>, <em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">'KL'</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'SLSQP'</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_value</span><span class="o">=</span><span class="default_value">1e-10</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/fit.html#GaussianBasisFit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.GaussianBasisFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_BaseFit</span></code></p>
<p>Optimizes either least-squares or Kullback-Leibler of Gaussian funcs using <cite>Scipy.optimize</cite>.</p>
<dl class="simple">
<dt>The Gaussian functions can be constrained to have their integral be a fixed value.</dt><dd><dl class="simple">
<dt>Although it is not recommended. The coefficients and exponents are always bounded to be</dt><dd><p>positive.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt id="bfit.GaussianBasisFit.grid">
<code class="sig-name descname">grid</code><a class="headerlink" href="#bfit.GaussianBasisFit.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid class that contains the grid points and integration methods on them.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(_BaseRadialGrid, <a class="reference internal" href="grid/index.html#bfit.grid.CubicGrid" title="bfit.grid.CubicGrid">CubicGrid</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.GaussianBasisFit.density">
<code class="sig-name descname">density</code><a class="headerlink" href="#bfit.GaussianBasisFit.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The true function evaluated on the grid points from <cite>grid</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.GaussianBasisFit.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#bfit.GaussianBasisFit.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The Gaussian basis model density. Located in <cite>model.py</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#bfit.AtomicGaussianDensity" title="bfit.AtomicGaussianDensity">AtomicGaussianDensity</a>, <a class="reference internal" href="#bfit.MolecularGaussianDensity" title="bfit.MolecularGaussianDensity">MolecularGaussianDensity</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.GaussianBasisFit.measure">
<code class="sig-name descname">measure</code><a class="headerlink" href="#bfit.GaussianBasisFit.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>The deviation measure between true density and model density that is minimized.
Can be either be “KL” (Kullback-Leibler, default) or “LS” (least-squares).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.GaussianBasisFit.norm">
<code class="sig-name descname">norm</code><a class="headerlink" href="#bfit.GaussianBasisFit.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>The integration of the density over the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">run() :</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">func() :</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">evaluate_model() :</code></dt>
<dd></dd></dl>

<p class="rubric">Examples</p>
<p>The goal is to fit a Gaussian density to some function.
def f(x) :</p>
<blockquote>
<div><p># Insert what it does here.
return …</p>
</div></blockquote>
<p>The first step is to define the grid object.
&gt;&gt; grid = CubicGrid(0.01, 0.99, 0.01)</p>
<p>Place the values of <cite>f</cite> on those grid points in an array.
&gt;&gt; density = f(grid.points)</p>
<p>Define the model, that you want to fit with.
&gt;&gt; model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)</p>
<p>Define which measure (least-squares) and “scipy.optimize” algorithm to use.
&gt;&gt; fit = GaussianBasisFit(grid, density, model, measure=”LS”, method=”SLSQP”)</p>
<p>Optimize the coefficients and exponents but give an initial guess.
&gt;&gt; initc = [1.] * 10
&gt;&gt; inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
&gt;&gt; result = fit.run(initc, inite)</p>
<p>Print out the results.
&gt;&gt; print(“Optimized coefficients are: “, result[“x”][0])
&gt;&gt; print(“Optimized exponents are: “, result[“x”][1])
&gt;&gt; print(“Final performance measures are: “, result[“performance”])
&gt;&gt; print(“Was it successful? “, result[“success”])
&gt;&gt; print(“Why it terminated? “, result[“message”])</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The coefficients and exponents are bounded to be positive.</p></li>
<li><dl class="simple">
<dt>These methods in this class was found to be extremely hard to optimize. There appears</dt><dd><p>to have many local minimas and Quasi-Newton methods seems inadequate in order to optimize
these. Just the mere act of placing the initial guess to be close to the solution causes
problems. It is highly recommended to have <cite>with_constraint</cite> to be False.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note that the Kullback-Leibler between two functions f and g is positive if and only if</dt><dd><p>the integrals of f and g are identical.  This constraint must be added for
these optimizers.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="bfit.GaussianBasisFit.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">c0</span></em>, <em class="sig-param"><span class="n">e0</span></em>, <em class="sig-param"><span class="n">opt_coeffs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">opt_expons</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">with_constraint</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GaussianBasisFit.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize coefficients and/or exponents of Gaussian basis functions with constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c0</strong> (<em>ndarray</em>) – Initial guess for coefficients of Gaussian basis functions.</p></li>
<li><p><strong>e0</strong> (<em>ndarray</em>) – Initial guess for exponents of Gaussian basis functions.</p></li>
<li><p><strong>opt_coeffs</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize coefficients of Gaussian basis functions.</p></li>
<li><p><strong>opt_expons</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize exponents of Gaussian basis functions.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – For slsqp. precision goal for the value of objective function in the stopping criterion.
For trust-constr, it is precision goal for the change in independent variables.</p></li>
<li><p><strong>disp</strong> (<em>bool</em>) – If True, then it will print the convergence messages from the optimizer.</p></li>
<li><p><strong>with_constraint</strong> (<em>bool</em>) – If true, then adds the constraint that the integration of the model density must
be equal to the constraint of true density. The default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> – The optimization results presented as a dictionary containing:
“x” : (ndarray, ndarray)</p>
<blockquote>
<div><p>The optimized coefficients and exponents, respectively.</p>
</div></blockquote>
<dl class="simple">
<dt>”success”: bool</dt><dd><p>Whether or not the optimization exited successfully.</p>
</dd>
<dt>”message”<span class="classifier">str</span></dt><dd><p>Message about the cause of termination.</p>
</dd>
<dt>”fun”<span class="classifier">float</span></dt><dd><p>Values of KL divergence (objective function) at the final iteration.</p>
</dd>
<dt>”jacobian”: ndarray</dt><dd><p>The Jacobian of the coefficients and exponents.</p>
</dd>
<dt>”performance”<span class="classifier">list</span></dt><dd><p>Values of various performance measures of modeled density at each iteration,
as computed by <cite>_BaseFit.goodness_of_fit</cite> method.</p>
</dd>
<dt>”time”<span class="classifier">float</span></dt><dd><p>The time in seconds it took to optimize.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>This is a constrained optimization such that the integration of the model density is</dt><dd><p>a fixed value. Hence, only certain optimization algorithms can be used.</p>
</dd>
</dl>
</li>
<li><p>The coefficients and exponents are bounded to be positive.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="bfit.GaussianBasisFit.func">
<code class="sig-name descname">func</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GaussianBasisFit.func" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute objective function and its derivative w.r.t. Gaussian basis parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The parameters of Gaussian basis which is being optimized. Contains both the
coefficients and exponents together in a 1-D array.</p></li>
<li><p><strong>args</strong> – Additional arguments to the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The objective function value and its derivative wrt to coefficients and exponents.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.GaussianBasisFit.const_norm">
<code class="sig-name descname">const_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GaussianBasisFit.const_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute deviation in normalization constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The parameters of Gaussian basis which is being optimized. Contains both the
coefficients and exponents together in a 1-D array.</p></li>
<li><p><strong>args</strong> – Additional parameters for the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The deviation of the integrla with the normalization constant.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.GaussianBasisFit.evaluate_model">
<code class="sig-name descname">evaluate_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GaussianBasisFit.evaluate_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the model density &amp; its derivative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The parameters of Gaussian basis which is being optimized. Contains both the
coefficients and exponents together in a 1-D array.</p></li>
<li><p><strong>args</strong> – Additional parameters for the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Evaluates the model density &amp; its derivative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.ClenshawRadialGrid">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">ClenshawRadialGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">atomic_number</span></em>, <em class="sig-param"><span class="n">num_core_pts</span></em>, <em class="sig-param"><span class="n">num_diffuse_pts</span></em>, <em class="sig-param"><span class="n">extra_pts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">spherical</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/grid.html#ClenshawRadialGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.ClenshawRadialGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_BaseRadialGrid</span></code></p>
<p>Clenshaw-Curtis Radial Grid Class.</p>
<p>The Clenshaw-Curtis grid places more points closer to the origin of the interval <span class="math notranslate nohighlight">\([0, \inf).\)</span>
It is defined as follows. Let <span class="math notranslate nohighlight">\(Z, m, n\)</span> be the atomic number, number of points near origin,
and the number of points far from the origin, respectively.</p>
<p>Then each point <span class="math notranslate nohighlight">\(r_p\)</span> of the Clenshaw radial grid is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
    r_p = \frac{1}{2Z} \bigg(1 - \cos\bigg(\frac{\pi p}{400} \bigg)\bigg)  &amp; p = 0, 1, \cdots, m - 1 \\
    r_p = 25 \bigg(1 - \cos\bigg(\frac{\pi p}{600} \bigg)\bigg) &amp; p = 0, 1, \cdocts, n - 1\\
\end{eqnarray}\end{split}\]</div>
<dl class="py attribute">
<dt id="bfit.ClenshawRadialGrid.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#bfit.ClenshawRadialGrid.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The radial grid points of a one-dimensional grid with N points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.ClenshawRadialGrid.atomic_number">
<code class="sig-name descname">atomic_number</code><a class="headerlink" href="#bfit.ClenshawRadialGrid.atomic_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atomic number.</p>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.ClenshawRadialGrid.spherical">
<code class="sig-name descname">spherical</code><a class="headerlink" href="#bfit.ClenshawRadialGrid.spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, then trapezoidal integration is done spherically (ie with a factor of <span class="math notranslate nohighlight">\(4 \pi r^2\)</span>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.ClenshawRadialGrid.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.ClenshawRadialGrid.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate array <cite>arr</cite> defined over “point” array using trapezoidal integration.</p>
</dd></dl>

<dl class="py method">
<dt id="id1">
<em class="property">property </em><code class="sig-name descname">atomic_number</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atomic number.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.ClenshawRadialGrid._get_points">
<code class="sig-name descname">_get_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">num_pts</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'core'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.ClenshawRadialGrid._get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate radial points on [0, inf) based on Clenshaw-Curtis grid.</p>
<p>The “core” points are concentrated near the origin based on:</p>
<div class="math notranslate nohighlight">
\[r_p = 25 (1 - cos(\frac{\pi p}{2N})) for p =0,1..N-1\]</div>
<p>The “diffuse” points are concentrated away from the origin based on:</p>
<div class="math notranslate nohighlight">
\[r_p = \frac{1}[2Z} (1 - cos(\frac{\pi p}{2N})) for p=0,1...N-1,\]</div>
<p>where <span class="math notranslate nohighlight">\(Z\)</span> is the atomic number and <span class="math notranslate nohighlight">\(N\)</span> is the number of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_pts</strong> (<em>int</em>) – The number of points.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – If “core”, the points are placed closer to the origin. If “diffuse”, the points are
placed far away from origin.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong> – The 1D array of grid points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, (N,)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.UniformRadialGrid">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">UniformRadialGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_pts</span></em>, <em class="sig-param"><span class="n">min_radii</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">max_radii</span><span class="o">=</span><span class="default_value">100.0</span></em>, <em class="sig-param"><span class="n">spherical</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/grid.html#UniformRadialGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.UniformRadialGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_BaseRadialGrid</span></code></p>
<p>Uniformly Distributed Radial Grid Class.</p>
<p>The grid points are equally-spaced in <span class="math notranslate nohighlight">\([0, max_points)\)</span> interval.</p>
<dl class="py attribute">
<dt id="bfit.UniformRadialGrid.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#bfit.UniformRadialGrid.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The radial grid points of a one-dimensional grid with N points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.UniformRadialGrid.spherical">
<code class="sig-name descname">spherical</code><a class="headerlink" href="#bfit.UniformRadialGrid.spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, then trapezoidal integration is done spherically (ie with a factor of <span class="math notranslate nohighlight">\(4 \pi r^2\)</span>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.UniformRadialGrid.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.UniformRadialGrid.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate array <cite>arr</cite> defined over “point” array using trapezoidal integration.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.CubicGrid">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">CubicGrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">axes</span></em>, <em class="sig-param"><span class="n">shape</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/grid.html#CubicGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.CubicGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Equally-Spaced 3D Cubic Grid Class.</p>
<dl class="py attribute">
<dt id="bfit.CubicGrid.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#bfit.CubicGrid.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The three-dimensional array containing the <cite>N</cite> grid points that are uniform.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, (N, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.CubicGrid.step">
<code class="sig-name descname">step</code><a class="headerlink" href="#bfit.CubicGrid.step" title="Permalink to this definition">¶</a></dt>
<dd><p>The positive number representing the step-size of any two consequent grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">integrate(arr) :</code></dt>
<dd><p>Integrate an array <cite>arr</cite> defined over the <cite>points</cite> using Riemannian sum.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.CubicGrid.axes">
<em class="property">property </em><code class="sig-name descname">axes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.CubicGrid.axes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.CubicGrid.from_molecule">
<em class="property">classmethod </em><code class="sig-name descname">from_molecule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">atcorenums</span></em>, <em class="sig-param"><span class="n">atcoords</span></em>, <em class="sig-param"><span class="n">spacing</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">extension</span><span class="o">=</span><span class="default_value">5.0</span></em>, <em class="sig-param"><span class="n">rotate</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.CubicGrid.from_molecule" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a uniform grid given the molecular pseudo-numbers and coordinates.
:param atcorenums: Pseudo-number of <span class="math notranslate nohighlight">\(M\)</span> atoms in the molecule.
:type atcorenums: np.ndarray, shape (M,)
:param atcoords: Cartesian coordinates of <span class="math notranslate nohighlight">\(M\)</span> atoms in the molecule.
:type atcoords: np.ndarray, shape (M, 3)
:param spacing: Increment between grid points along <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> direction.
:type spacing: float, optional
:param extension: The extension of the length of the cube on each side of the molecule.
:type extension: float, optional
:param rotate: When True, the molecule is rotated so the axes of the cube file are</p>
<blockquote>
<div><p>aligned with the principle axes of rotation of the molecule.
If False, generates axes based on the x,y,z-axis and the spacing parameter, and
the origin is defined by the maximum/minimum of the atomic coordinates.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.CubicGrid._calculate_volume">
<code class="sig-name descname">_calculate_volume</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.CubicGrid._calculate_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the volume of the Uniform Grid.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.CubicGrid._choose_weight_scheme">
<code class="sig-name descname">_choose_weight_scheme</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">shape</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.CubicGrid._choose_weight_scheme" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="id2">
<em class="property">property </em><code class="sig-name descname">points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cubic grid points.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.CubicGrid.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.CubicGrid.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of grid points.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.CubicGrid.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">arr</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.CubicGrid.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral of a function evaluated on the grid points based on Riemann sums.</p>
<div class="math notranslate nohighlight">
\[\int\int\int f(x, y, z) dx dy dz\]</div>
<p>where :math:’f(r)’ is the integrand.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>ndarray</em>) – The integrand evaluated on the grid points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – The value of integral.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.AtomicGaussianDensity">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">AtomicGaussianDensity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_s</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">num_p</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/model.html#AtomicGaussianDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.AtomicGaussianDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian density model for modeling the electronic density of a single atom.</p>
<dl class="simple">
<dt>Atomic Gaussian density is a linear combination of Gaussian functions of S-type</dt><dd><p>and P-type functions:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[f(x) := \sum_i c_i e^{-\alpha_i |x - c|^2} + d_i |x - c|^2 e^{-\beta |x - c|^2}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(c_i, d_i\)</span> are the coefficients of S-type and P-type functions.
<span class="math notranslate nohighlight">\(c\)</span> is the center of the Gaussian functions.
<span class="math notranslate nohighlight">\(x\)</span> is the real coordinates, can be multi-dimensional.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="bfit.AtomicGaussianDensity.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#bfit.AtomicGaussianDensity.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The grid points, where N is the number of points and D is the dimension of a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N, D)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicGaussianDensity.radii">
<code class="sig-name descname">radii</code><a class="headerlink" href="#bfit.AtomicGaussianDensity.radii" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance of points from the center <span class="math notranslate nohighlight">\(c\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N, D)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicGaussianDensity.num_s">
<code class="sig-name descname">num_s</code><a class="headerlink" href="#bfit.AtomicGaussianDensity.num_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of S-type Gaussian basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicGaussianDensity.num_p">
<code class="sig-name descname">num_p</code><a class="headerlink" href="#bfit.AtomicGaussianDensity.num_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of P-type Gaussian basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicGaussianDensity.nbasis">
<code class="sig-name descname">nbasis</code><a class="headerlink" href="#bfit.AtomicGaussianDensity.nbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of basis functions (including S-type and P-type Gaussians).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicGaussianDensity.natoms">
<code class="sig-name descname">natoms</code><a class="headerlink" href="#bfit.AtomicGaussianDensity.natoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of atom or number of centers for Gaussian function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">evaluate(deriv='False') :</code></dt>
<dd><p>Return Gaussian density function on <cite>radii</cite> by providing coefficients and exponents.
If <cite>deriv</cite> is True, then derivative with respect to the coefficient and exponent is
also returned.</p>
</dd></dl>

<p class="rubric">Examples</p>
<p>First define a grid.
&gt;&gt; point = [-0.5, -0.25, 0., 0.25, 0.5]</p>
<p>Define the center.
&gt;&gt; center = np.array([-1.])</p>
<p>Define the Model using 5 S-Type and P-type.
&gt;&gt; model = AtomicGaussianDensity(point, center=center, num_s=5, num_p=5)</p>
<p>Put first 5 coefficients of S-type followed by P-type. Same with exponents.
&gt;&gt; coeff = np.array([1., 2., 3., 4., 5., 1., 2., 3., 4., 5.])
&gt;&gt; exps = np.array([0.05, 0.1, 0.2, 0.3, 0.4, 0.01, 0.02, 0.03, 0.04, 0.05])
&gt;&gt; model.evaluate(coeff, exps)</p>
<dl class="py method">
<dt id="id3">
<em class="property">property </em><code class="sig-name descname">points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the grid points.</p>
</dd></dl>

<dl class="py method">
<dt id="id4">
<em class="property">property </em><code class="sig-name descname">radii</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distance of grid points from center of Gaussian(s).</p>
</dd></dl>

<dl class="py method">
<dt id="id5">
<em class="property">property </em><code class="sig-name descname">num_s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of s-type Gaussian basis functions.</p>
</dd></dl>

<dl class="py method">
<dt id="id6">
<em class="property">property </em><code class="sig-name descname">num_p</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id6" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of p-type Gaussian basis functions.</p>
</dd></dl>

<dl class="py method">
<dt id="id7">
<em class="property">property </em><code class="sig-name descname">nbasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id7" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of Gaussian basis functions.</p>
</dd></dl>

<dl class="py method">
<dt id="id8">
<em class="property">property </em><code class="sig-name descname">natoms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id8" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions centers.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicGaussianDensity.prefactor">
<em class="property">property </em><code class="sig-name descname">prefactor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicGaussianDensity.prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain list of exponents for the prefactors.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicGaussianDensity.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">expons</span></em>, <em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicGaussianDensity.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute linear combination of Gaussian basis &amp; its derivatives on the grid points.</p>
<div class="math notranslate nohighlight">
\[f(x) := \sum_i c_i e^{-\alpha_i |x - c|^2} + d_i |x - c|^2 e^{-\beta |x-c|^2}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(c_i, d_i\)</span> are the coefficients of S-type and P-type functions.
<span class="math notranslate nohighlight">\(c\)</span> is the center of the Gaussian functions.
<span class="math notranslate nohighlight">\(x\)</span> is the real coordinates, can be multi-dimensional.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (ndarray, (<cite>nbasis</cite>,)) – The coefficients of <cite>num_s</cite> s-type Gaussian basis functions followed by the
coefficients of <cite>num_p</cite> p-type Gaussian basis functions.</p></li>
<li><p><strong>expons</strong> (ndarray, (<cite>nbasis</cite>,)) – The exponents of <cite>num_s</cite> s-type Gaussian basis functions followed by the
exponents of <cite>num_p</cite> p-type Gaussian basis functions.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &amp;
exponents.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>g</strong> (<em>ndarray, (N,)</em>) – The linear combination of Gaussian basis functions evaluated on the grid points.</p></li>
<li><p><strong>dg</strong> (ndarray, (N, 2 * <cite>nbasis</cite>)) – The derivative of a linear combination of Gaussian basis functions w.r.t. coefficients
&amp; exponents, respectively, evaluated on the grid points. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicGaussianDensity._eval_s">
<code class="sig-name descname">_eval_s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">matrix</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">expons</span></em>, <em class="sig-param"><span class="n">deriv</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicGaussianDensity._eval_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute linear combination of s-type Gaussian basis &amp; its derivative on the grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>, </em><em>M</em><em>)</em>) – The exp(-a * r**2) array evaluated on grid points for each exponent.</p></li>
<li><p><strong>coeffs</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>,</em><em>)</em>) – The coefficients of Gaussian basis functions.</p></li>
<li><p><strong>expons</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>,</em><em>)</em>) – The exponents of Gaussian basis functions.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &amp;
exponents.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>g</strong> (<em>ndarray, (N,)</em>) – The linear combination of s-type Gaussian basis functions evaluated on the grid points.</p></li>
<li><p><strong>dg</strong> (<em>ndarray, (N, 2*M)</em>) – The derivative of linear combination of s-type Gaussian basis functions w.r.t.
coefficients (the 1st M columns) &amp; exponents (the 2nd M columns) evaluated on the
grid points. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicGaussianDensity._eval_p">
<code class="sig-name descname">_eval_p</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">matrix</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">expons</span></em>, <em class="sig-param"><span class="n">deriv</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicGaussianDensity._eval_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute linear combination of P-type Gaussian basis &amp; its derivative on the grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>, </em><em>M</em><em>)</em>) – The exp(-a * r**2) array evaluated on grid points for each exponent.</p></li>
<li><p><strong>coeffs</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>,</em><em>)</em>) – The coefficients of Gaussian basis functions.</p></li>
<li><p><strong>expons</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>,</em><em>)</em>) – The exponents of Gaussian basis functions.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &amp;
exponents.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>g</strong> (<em>ndarray, (N,)</em>) – The linear combination of p-type Gaussian basis functions evaluated on the grid points.</p></li>
<li><p><strong>dg</strong> (<em>ndarray, (N, 2*M)</em>) – The derivative of linear combination of p-type Gaussian basis functions w.r.t.
coefficients (the 1st M columns) &amp; exponents (the 2nd M columns) evaluated on the
grid points. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.MolecularGaussianDensity">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">MolecularGaussianDensity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">coords</span></em>, <em class="sig-param"><span class="n">basis</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/model.html#MolecularGaussianDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.MolecularGaussianDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Molecular Atom-Centered Gaussian Density Model.</p>
<dl class="simple">
<dt>The Molecular Gaussian Density model is based on multiple centers each associated with a</dt><dd><p>Gaussian density model (S or P-type) of any dimension.</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}f(x) := \sum_j \sum_{i =1}^{M_j} c_{ji} e^{-\alpha_{ji} |x - m_j|^2} +
                                     d_{ji} |x - m_j|^2 e^{-\beta_{ji} |x - m_j|^2}\\where
    :math:`c_{ji}, d_{ji}` are the ith coefficients of S-type and P-type functions of the
        jth center.
    :math:`\alpha_{ji}, \beta_{ji}` are the ith exponents of S-type and P-type functions of
        the jth center.
    :math:`M_j` is the total number of basis functions of the jth center.
    :math:`m_j` is the coordinate of the jth center.
    :math:`x` is the real coordinates of the point. It can be of any dimension.\end{aligned}\end{align} \]</div>
<dl class="py attribute">
<dt id="bfit.MolecularGaussianDensity.points">
<code class="sig-name descname">points</code><a class="headerlink" href="#bfit.MolecularGaussianDensity.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The grid points in a two-dimensional array, where N is the number of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(N, 3) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.MolecularGaussianDensity.radii">
<code class="sig-name descname">radii</code><a class="headerlink" href="#bfit.MolecularGaussianDensity.radii" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance of <cite>points</cite> from each center, where M is the number of centers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(M, N) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.MolecularGaussianDensity.num_s">
<code class="sig-name descname">num_s</code><a class="headerlink" href="#bfit.MolecularGaussianDensity.num_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of S-type Gaussian basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.MolecularGaussianDensity.num_p">
<code class="sig-name descname">num_p</code><a class="headerlink" href="#bfit.MolecularGaussianDensity.num_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of P-type Gaussian basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.MolecularGaussianDensity.nbasis">
<code class="sig-name descname">nbasis</code><a class="headerlink" href="#bfit.MolecularGaussianDensity.nbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of basis functions (including S-type and P-type Gaussians).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.MolecularGaussianDensity.natoms">
<code class="sig-name descname">natoms</code><a class="headerlink" href="#bfit.MolecularGaussianDensity.natoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of atom or number of centers.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">evaluate(deriv='False') :</code></dt>
<dd><p>Return Gaussian density function on <cite>radii</cite> by providing coefficients and exponents.
If <cite>deriv</cite> is True, then derivative with respect to the coefficient and exponent is
also returned.</p>
</dd></dl>

<dl class="py method">
<dt id="id9">
<em class="property">property </em><code class="sig-name descname">points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id9" title="Permalink to this definition">¶</a></dt>
<dd><p>Get grid points.</p>
</dd></dl>

<dl class="py method">
<dt id="id10">
<em class="property">property </em><code class="sig-name descname">nbasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id10" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total number of Gaussian basis functions.</p>
</dd></dl>

<dl class="py method">
<dt id="id11">
<em class="property">property </em><code class="sig-name descname">radii</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id11" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the distance of grid points from center of each basis function.</p>
</dd></dl>

<dl class="py method">
<dt id="id12">
<em class="property">property </em><code class="sig-name descname">natoms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Permalink to this definition">¶</a></dt>
<dd><p>Get number of basis functions centers.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.MolecularGaussianDensity.prefactor">
<em class="property">property </em><code class="sig-name descname">prefactor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.MolecularGaussianDensity.prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the pre-factor of Gaussian basis functions to make it normalized.</p>
<p>Only used if attribute <cite>normalize</cite> is true.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.MolecularGaussianDensity.assign_basis_to_center">
<code class="sig-name descname">assign_basis_to_center</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.MolecularGaussianDensity.assign_basis_to_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign the Gaussian basis function to the atomic center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index</strong> (<em>int</em>) – The index of Gaussian basis function.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>index</strong> – The index of atomic center.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.MolecularGaussianDensity.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">expons</span></em>, <em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.MolecularGaussianDensity.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute linear combination of Gaussian basis &amp; its derivatives on the grid points.</p>
<p>The Molecular Gaussian is defined to be:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:=</span> \<span class="n">sum_j</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">M_j</span><span class="p">}</span> <span class="n">c_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span> <span class="o">|</span><span class="n">x</span> <span class="o">-</span> <span class="n">m_j</span><span class="o">|^</span><span class="mi">2</span><span class="p">}</span> <span class="o">+</span>
                                 <span class="n">d_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span> <span class="o">|</span><span class="n">x</span> <span class="o">-</span> <span class="n">m_j</span><span class="o">|^</span><span class="mi">2</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">beta_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span> <span class="o">|</span><span class="n">x</span> <span class="o">-</span> <span class="n">m_j</span><span class="o">|^</span><span class="mi">2</span><span class="p">}</span>
</pre></div>
</div>
<dl>
<dt>where</dt><dd><dl class="simple">
<dt><span class="math notranslate nohighlight">\(c_{ji}, d_{ji}\)</span> are the ith coefficients of S-type and P-type functions of the</dt><dd><p>jth center.</p>
</dd>
<dt><span class="math notranslate nohighlight">\(\alpha_{ji}, \beta_{ji}\)</span> are the ith exponents of S-type and P-type functions of</dt><dd><p>the jth center.</p>
</dd>
</dl>
<p><span class="math notranslate nohighlight">\(M_j\)</span> is the total number of basis functions of the jth center.
<span class="math notranslate nohighlight">\(m_j\)</span> is the coordinate of the jth center.
<span class="math notranslate nohighlight">\(x\)</span> is the real coordinates of the point.</p>
</dd>
</dl>
<p>Its derivative with respect to exponent of a single Gaussian with center <span class="math notranslate nohighlight">\(m_j\)</span> is:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">frac</span><span class="p">{</span>\<span class="n">partial</span> <span class="n">f</span><span class="p">}{</span>\<span class="n">partial</span> \<span class="n">alpha_</span><span class="p">{</span><span class="n">ji</span><span class="p">}}</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span> <span class="o">|</span><span class="n">x</span> <span class="o">-</span> <span class="n">m_j</span><span class="o">|^</span><span class="mi">2</span><span class="p">}</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (ndarray, (<cite>nbasis</cite>,)) – The coefficients of <cite>num_s</cite> s-type Gaussian basis functions followed by the
coefficients of <cite>num_p</cite> p-type Gaussian basis functions.</p></li>
<li><p><strong>expons</strong> (ndarray, (<cite>nbasis</cite>,)) – The exponents of <cite>num_s</cite> s-type Gaussian basis functions followed by the
exponents of <cite>num_p</cite> p-type Gaussian basis functions.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &amp;
exponents.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>g</strong> (<em>ndarray, (N,)</em>) – The linear combination of Gaussian basis functions evaluated on the grid points.</p></li>
<li><p><strong>dg</strong> (ndarray, (N, <cite>nbasis</cite>)) – The derivative of linear combination of Gaussian basis functions w.r.t. coefficients
&amp; exponents, respectively, evaluated on the grid points. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.AtomicDensity">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">AtomicDensity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em>, <em class="sig-param"><span class="n">anion</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">cation</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/density.html#AtomicDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.AtomicDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic Density Class.</p>
<p>Reads and Parses information from the .slater file of a atom and stores it inside this class.
It is then able to construct the (total, core and valence) electron density based
on linear combination of orbitals where each orbital is a linear combination of
Slater-type orbitals.
Elements supported by default from “./bfit/data/examples/” range from Hydrogen to Xenon.</p>
<dl class="py attribute">
<dt>
<code class="sig-name descname">Attributes relating to the standard electron configuration.</code></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.energy">
<code class="sig-name descname">energy</code><a class="headerlink" href="#bfit.AtomicDensity.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Energy of that atom.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.configuration">
<code class="sig-name descname">configuration</code><a class="headerlink" href="#bfit.AtomicDensity.configuration" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the electron configuration of the element.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbitals">
<code class="sig-name descname">orbitals</code><a class="headerlink" href="#bfit.AtomicDensity.orbitals" title="Permalink to this definition">¶</a></dt>
<dd><p>List of strings representing each of the orbitals in the electron configuration.
For example, Beryllium has [“1S”, “2S”] in its electron configuration.
Ordered based on “S”, “P”, “D”, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list, (M,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbitals_occupation">
<code class="sig-name descname">orbitals_occupation</code><a class="headerlink" href="#bfit.AtomicDensity.orbitals_occupation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of electrons in each of the orbitals in the electron configuration.
e.g. Beryllium has two electrons in “1S” and two electrons in “2S”.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray, (M, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">Attributes relating to representing orbitals as linear combination of Slater-type orbitals.</code></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbital_energy">
<code class="sig-name descname">orbital_energy</code><a class="headerlink" href="#bfit.AtomicDensity.orbital_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Energy of each of the N Slater-type orbital.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list, (N, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbitals_cusp">
<code class="sig-name descname">orbitals_cusp</code><a class="headerlink" href="#bfit.AtomicDensity.orbitals_cusp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cusp of each of the N Slater-type orbital. Same ordering as <cite>orbitals</cite>. Does not exist
for Heavy atoms past Xenon.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list, (N, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbitals_basis">
<code class="sig-name descname">orbitals_basis</code><a class="headerlink" href="#bfit.AtomicDensity.orbitals_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys are the orbitals in the electron configuration. Each orbital has N Slater-type orbital
attached to them.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbitals_exp">
<code class="sig-name descname">orbitals_exp</code><a class="headerlink" href="#bfit.AtomicDensity.orbitals_exp" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Key is the orbital in the electron configuration and the item of that key is the Slater</dt><dd><p>exponents attached
to each N Slater-type orbital.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict (str : ndarray(N, 1))</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.orbitals_coeff">
<code class="sig-name descname">orbitals_coeff</code><a class="headerlink" href="#bfit.AtomicDensity.orbitals_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Key is the orbital in the electron configuration (e. 1S, 2S or 2P) and the item is the
Slater coefficients attached to each of the N Slater-type orbital.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict (str : ndarray(N, 1))</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.AtomicDensity.basis_numbers">
<code class="sig-name descname">basis_numbers</code><a class="headerlink" href="#bfit.AtomicDensity.basis_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Key is orbital in electron configuration and the item is the basis number of each of
the N Slater-type orbital. These are the principal quantum number to each Slater-type
orbital.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict (str : ndarray(N, 1))</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">atomic_density(mode=&quot;total&quot;) :</code></dt>
<dd><p>Construct the atomic density from the linear combinations of slater-type orbitals.
Can compute the total (default), core and valence atomic density.</p>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">lagrangian_kinetic_energy :</code></dt>
<dd><p>Construct the Positive Definite Kinetic energy.</p>
</dd></dl>

<p class="rubric">Examples</p>
<p>Grab information about Beryllium.
&gt;&gt; be =  AtomicDensity(“be”)</p>
<p>Some of the attributes are the following.
&gt;&gt; print(be.configuration) #  Should “1S(2)2S(2)”.
&gt;&gt; print(be.orbitals)  # [‘1S’, ‘2S’].
&gt;&gt; print(be.orbitals_occupation) # [[2], [2]] Two electrons in each orbital.
&gt;&gt; print(be.orbitals_cusp)  # [1.0001235, 0.9998774].</p>
<p>The Slatar coefficients and exponents of the 1S orbital can be obtained as:
&gt;&gt; print(be.orbital_coeff[“1S”])
&gt;&gt; print(be.orbitals_exp[“1S”])</p>
<p>The total, core and valence electron density can be obtained as:
&gt;&gt; points = np.arange(0., 25., 0.01)
&gt;&gt; total_density = be.atomic_density(points, “total”)
&gt;&gt; core_density = be.atomic_density(points, “core”)
&gt;&gt; valence_density = be.atomic_density(points, “valence”)</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] “Analytical Hartree–Fock wave functions subject to cusp and asymptotic constraints:</dt><dd><p>He to Xe, Li+ to Cs+, H− to I−” by T. Koga, K. Kanayama, S. Watanabe and A.J. Thakkar.</p>
</dd>
</dl>
<dl class="py method">
<dt id="bfit.AtomicDensity.slater_orbital">
<em class="property">static </em><code class="sig-name descname">slater_orbital</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exponent</span></em>, <em class="sig-param"><span class="n">number</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicDensity.slater_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Slater-type orbitals on the given points.</p>
<p>A Slater-type orbital is defined as:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">N</span> <span class="n">r</span><span class="o">^</span><span class="p">{</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span> <span class="n">C</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(n\)</span> is the principal quantum number of that orbital.
<span class="math notranslate nohighlight">\(N\)</span> is the normalizing constant.
<span class="math notranslate nohighlight">\(r\)</span> is the radial point, distance to the origin.
<span class="math notranslate nohighlight">\(C\)</span> is the zeta exponent of that orbital.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>exponent</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>, </em><em>1</em><em>)</em>) – The zeta exponents of Slater orbitals.</p></li>
<li><p><strong>number</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>, </em><em>1</em><em>)</em>) – The principle quantum numbers of Slater orbitals.</p></li>
<li><p><strong>points</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>,</em><em>)</em>) – The radial grid points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>slater</strong> – The Slater-type orbitals evaluated on the grid points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, (N, M)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">The()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">The()</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicDensity.phi_matrix">
<code class="sig-name descname">phi_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicDensity.phi_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linear combination of Slater-type atomic orbitals on the given points.</p>
<dl class="simple">
<dt>Each row corresponds to a point on the grid, represented as <span class="math notranslate nohighlight">\(r\)</span> and</dt><dd><p>each column is represented as a linear combination of Slater-type atomic orbitals
of the form:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[\sum c_i R(r, n_i, C_i)\]</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(c_i\)</span> is the coefficient of the Slater-type orbital.
<span class="math notranslate nohighlight">\(C_i\)</span> is the zeta exponent attached to the Slater-type orbital.
<span class="math notranslate nohighlight">\(n_i\)</span> is the principal quantum number attached to the Slater-type orbital.
<span class="math notranslate nohighlight">\(R(r, n_i, C_i)\)</span> is the Slater-type orbital.
i ranges from 0 to K-1 where K is the number of orbitals in electron configuration.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>,</em><em>)</em>) – The radial grid points.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em>) – If true, use the derivative of the slater-orbitals.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>phi_matrix</strong> – The linear combination of Slater-type orbitals evaluated on the grid points, where K is
the number of orbitals. The order is S orbitals, then P then D.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(N, K)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>At r = 0, the derivative of slater-orbital is undefined and this function returns</dt><dd><p>zero instead. See “derivative_slater_type_orbital”.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicDensity.atomic_density">
<code class="sig-name descname">atomic_density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">points</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'total'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicDensity.atomic_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute atomic density on the given points.</p>
<p>The total density is written as a linear combination of Slater-type orbital
whose coefficients is the orbital occupation number of the electron configuration:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="nb">sum</span> <span class="n">n_i</span> <span class="o">|</span><span class="n">P</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n_i</span><span class="p">,</span> <span class="n">C_i</span><span class="p">)</span><span class="o">|^</span><span class="mi">2</span>
</pre></div>
</div>
<dl>
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(n_i\)</span> is the number of electrons in orbital i.
<span class="math notranslate nohighlight">\(P(r, n_i, C_i)\)</span> is a linear combination of Slater-type orbitals evaluated</p>
<blockquote>
<div><p>on the point <span class="math notranslate nohighlight">\(r\)</span>.</p>
</div></blockquote>
</dd>
</dl>
<p>For core and valence density, please see More Info below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>,</em><em>)</em>) – The radial grid points.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – The type of atomic density, which can be “total”, “valence” or “core”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dens</strong> – The atomic density on the grid points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, (N,)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The core density and valence density is respectively written as:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="nb">sum</span> <span class="n">n_i</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-|</span><span class="n">e_i</span> <span class="o">-</span> <span class="n">e_</span><span class="p">{</span><span class="n">homo</span><span class="p">}</span><span class="o">|^</span><span class="mi">2</span><span class="p">})</span> <span class="o">|</span><span class="n">P</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n_i</span><span class="p">,</span> <span class="n">C_i</span><span class="p">)</span><span class="o">|</span>
\<span class="nb">sum</span> <span class="n">n_i</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-|</span><span class="n">e_i</span> <span class="o">-</span> <span class="n">e_</span><span class="p">{</span><span class="n">homo</span><span class="p">}</span><span class="o">|^</span><span class="mi">2</span><span class="p">})</span> <span class="o">|</span><span class="n">P</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n_i</span><span class="o">.</span> <span class="n">C_i</span><span class="p">)</span><span class="o">|</span>
</pre></div>
</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(e_i\)</span> is the energy of the orbital i.
<span class="math notranslate nohighlight">\(e_{homo}\)</span> is the energy of the highest occupying orbital.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicDensity.derivative_slater_type_orbital">
<em class="property">static </em><code class="sig-name descname">derivative_slater_type_orbital</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exponent</span></em>, <em class="sig-param"><span class="n">number</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicDensity.derivative_slater_type_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the derivative of Slater-type orbitals on the given points.</p>
<p>A Slater-type orbital is defined as:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">frac</span><span class="p">{</span><span class="n">d</span> <span class="n">R</span><span class="p">(</span><span class="n">r</span><span class="p">)}{</span><span class="n">dr</span><span class="p">}</span> <span class="o">=</span> \<span class="n">bigg</span><span class="p">(</span>\<span class="n">frac</span><span class="p">{</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">}{</span><span class="n">r</span><span class="p">}</span> <span class="o">-</span> <span class="n">C</span> \<span class="n">bigg</span><span class="p">)</span> <span class="n">N</span> <span class="n">r</span><span class="o">^</span><span class="p">{</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span> <span class="n">C</span> <span class="n">r</span><span class="p">),</span>
</pre></div>
</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(n\)</span> is the principal quantum number of that orbital.
<span class="math notranslate nohighlight">\(N\)</span> is the normalizing constant.
<span class="math notranslate nohighlight">\(r\)</span> is the radial point, distance to the origin.
<span class="math notranslate nohighlight">\(C\)</span> is the zeta exponent of that orbital.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>exponent</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>, </em><em>1</em><em>)</em>) – The zeta exponents of Slater orbitals.</p></li>
<li><p><strong>number</strong> (<em>ndarray</em><em>, </em><em>(</em><em>M</em><em>, </em><em>1</em><em>)</em>) – The principle quantum numbers of Slater orbitals.</p></li>
<li><p><strong>points</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>,</em><em>)</em>) – The radial grid points. If points contain zero, then it is undefined at those
points and set to zero.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>slater</strong> – The Slater-type orbitals evaluated on the grid points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, (N, M)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>At r = 0, the derivative is undefined and this function returns zero instead.</p></li>
</ul>
<p class="rubric">References</p>
<p>See wikipedia page on “Slater-Type orbitals”.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicDensity.lagrangian_kinetic_energy">
<code class="sig-name descname">lagrangian_kinetic_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicDensity.lagrangian_kinetic_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Positive definite or Lagrangian kinetic energy density.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>ndarray</em><em>,</em><em>(</em><em>N</em><em>,</em><em>)</em>) – The radial grid points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>energy</strong> – The kinetic energy on the grid points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, (N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.AtomicDensity.derivative_density">
<code class="sig-name descname">derivative_density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.AtomicDensity.derivative_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the derivative of the atomic density on a set of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> (<em>ndarray</em><em>,</em><em>(</em><em>N</em><em>,</em><em>)</em>) – The radial grid points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>deriv</strong> – The derivative of atomic density on the grid points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, (N,)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.KLDivergence">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">KLDivergence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">mask_value</span><span class="o">=</span><span class="default_value">1e-12</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/measure.html#KLDivergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.KLDivergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Kullback-Leibler Divergence Class.</p>
<p>This is defined as the integral:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">D</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="o">:=</span> \<span class="n">int_G</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> \<span class="n">ln</span> <span class="p">(</span> \<span class="n">frac</span><span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)}{</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span> <span class="p">)</span> <span class="n">dx</span>
</pre></div>
</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(f\)</span> is the true probability distribution,
<span class="math notranslate nohighlight">\(g\)</span> is the model probability distribution,
<span class="math notranslate nohighlight">\(G\)</span> is the grid.</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="bfit.KLDivergence.density">
<code class="sig-name descname">density</code><a class="headerlink" href="#bfit.KLDivergence.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The true function (being approximated) evaluated on <cite>N</cite> points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.KLDivergence.mask_value">
<code class="sig-name descname">mask_value</code><a class="headerlink" href="#bfit.KLDivergence.mask_value" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Values of model density <cite>g</cite> that are less than <cite>mask_value</cite> are masked when used in division</dt><dd><p>and then replaced with the value of 1 so that logarithm of one is zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.KLDivergence.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.KLDivergence.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integrand <span class="math notranslate nohighlight">\(f(x) \ln(f(x)/g(x))\)</span> between model and true functions.
Note that it does not integrate the model, and so it doesn’t exactly return the
Kullback-Leibler. If <cite>deriv</cite> is True, then the derivative with respect to model function
is returned.</p>
</dd></dl>

<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>This class does not return the Kullback-Leibler but rather the integrand.</dt><dd><p>One would need to integrate this to get the Least Squared.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>It using masked values to handle overflow and underflow floating point precision issues. This</dt><dd><p>is due to the division in the Kullback-Leibler formula between two probability
distributions.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="id13">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id13" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the integrand of Kullback-Leibler divergence b/w true &amp; model.</p>
<div class="math notranslate nohighlight">
\[D(f, g) := \int_G f(x) \ln ( \frac{f(x)}{g(x)} ) dx\]</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(f\)</span> is the true probability distribution,
<span class="math notranslate nohighlight">\(g\)</span> is the model probability distribution,
<span class="math notranslate nohighlight">\(G\)</span> is the grid.</p>
</dd>
</dl>
<p>If the model density is negative, then this function will return extremely large values,
for optimization purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>,</em><em>)</em>) – The model density evaluated on the grid points.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute the derivative of divergence w.r.t. model density.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>m</strong> (<em>ndarray, (N,)</em>) – The divergence between density &amp; model on the grid points.</p></li>
<li><p><strong>dm</strong> (<em>ndarray, (N,)</em>) – The derivative of divergence w.r.t. model density evaluated on the grid points.
Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>Values of Model density that are less than <cite>mask_value</cite> are masked when used in</dt><dd><p>division and then replaced with the value of 1 so that logarithm of one is zero.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.SquaredDifference">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">SquaredDifference</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">density</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/bfit/measure.html#SquaredDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.SquaredDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Squared Difference Class for performing the Least-Squared method.</p>
<dl class="simple">
<dt>Least-squared is the defined to be the integral of the squared difference between</dt><dd><p>true and model functions:</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[||f - g|| = \int_G (f(x) - g(x))^2 dx\]</div>
<dl class="simple">
<dt>where,</dt><dd><p><span class="math notranslate nohighlight">\(f\)</span> is the true function,
<span class="math notranslate nohighlight">\(g\)</span> is the model function,
<span class="math notranslate nohighlight">\(G\)</span> is the grid.</p>
</dd>
</dl>
<p>The term <span class="math notranslate nohighlight">\(|f(x) - g(x)|^2\)</span> is called the Squared Difference between f and g on a point x.</p>
<dl class="py attribute">
<dt id="bfit.SquaredDifference.density">
<code class="sig-name descname">density</code><a class="headerlink" href="#bfit.SquaredDifference.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The true function (being approximated) evaluated on <cite>N</cite> points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.SquaredDifference.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.SquaredDifference.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the squared difference between model and true functions. Note that it does not
integrate the model but rather only computes f(x) - g(x). If <cite>deriv</cite> is True,
then the derivative with respect to model function is returned.</p>
</dd></dl>

<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>This class does not return the Least-Squared but rather the squared difference.</dt><dd><p>One would need to integrate this to get the Least Squared.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="id14">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">deriv</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id14" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate squared difference b/w density &amp; model on the grid points.</p>
<p>This is defined to be <span class="math notranslate nohighlight">\((f(x) - g(x))^2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>ndarray</em><em>, </em><em>(</em><em>N</em><em>,</em><em>)</em>) – The model density evaluated on the grid points.</p></li>
<li><p><strong>deriv</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute the derivative of squared difference w.r.t. model density.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>m</strong> (<em>ndarray, (N,)</em>) – The squared difference between density &amp; model on the grid points.</p></li>
<li><p><strong>dm</strong> (<em>ndarray, (N,)</em>) – The derivative of squared difference w.r.t. model density evaluated on the
grid points. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.GreedyStrategy">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">GreedyStrategy</code><a class="headerlink" href="#bfit.GreedyStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt id="bfit.GreedyStrategy.__metaclass__">
<code class="sig-name descname">__metaclass__</code><a class="headerlink" href="#bfit.GreedyStrategy.__metaclass__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.get_cost_function">
<em class="property">abstract </em><code class="sig-name descname">get_cost_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.get_cost_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.get_best_one_function_solution">
<em class="property">abstract </em><code class="sig-name descname">get_best_one_function_solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.get_best_one_function_solution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.get_next_iter_params">
<em class="property">abstract </em><code class="sig-name descname">get_next_iter_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.get_next_iter_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.get_optimization_routine">
<em class="property">abstract </em><code class="sig-name descname">get_optimization_routine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">local</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.get_optimization_routine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.get_errors_from_model">
<em class="property">abstract </em><code class="sig-name descname">get_errors_from_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.get_errors_from_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.store_errors">
<code class="sig-name descname">store_errors</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.store_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy._find_best_lparams">
<code class="sig-name descname">_find_best_lparams</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">param_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy._find_best_lparams" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">factor</span></em>, <em class="sig-param"><span class="n">max_numb_funcs</span><span class="o">=</span><span class="default_value">30</span></em>, <em class="sig-param"><span class="n">backward_elim_funcs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">add_choice_funcs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ioutput</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyStrategy._final_exit_info">
<code class="sig-name descname">_final_exit_info</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">num_func</span></em>, <em class="sig-param"><span class="n">max_func</span></em>, <em class="sig-param"><span class="n">best_val</span></em>, <em class="sig-param"><span class="n">prev_gval</span></em>, <em class="sig-param"><span class="n">redum</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyStrategy._final_exit_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.GreedyKL">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">GreedyKL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span></em>, <em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">norm</span></em>, <em class="sig-param"><span class="n">splitting_func</span><span class="o">=</span><span class="default_value">get_next_choices</span></em>, <em class="sig-param"><span class="n">eps_coeff</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">eps_exp</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">factor</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="greedy/greedy_strat/index.html#bfit.greedy.greedy_strat.GreedyStrategy" title="bfit.greedy.greedy_strat.GreedyStrategy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfit.greedy.greedy_strat.GreedyStrategy</span></code></a></p>
<dl class="py method">
<dt id="bfit.GreedyKL.density">
<em class="property">property </em><code class="sig-name descname">density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.density" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.norm">
<em class="property">property </em><code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.grid">
<em class="property">property </em><code class="sig-name descname">grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.get_model">
<code class="sig-name descname">get_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.get_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.get_cost_function">
<code class="sig-name descname">get_cost_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.get_cost_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.get_best_one_function_solution">
<code class="sig-name descname">get_best_one_function_solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.get_best_one_function_solution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.get_next_iter_params">
<code class="sig-name descname">get_next_iter_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">factor</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.get_next_iter_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.get_optimization_routine">
<code class="sig-name descname">get_optimization_routine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em>, <em class="sig-param"><span class="n">local</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.get_optimization_routine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyKL.get_errors_from_model">
<code class="sig-name descname">get_errors_from_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyKL.get_errors_from_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.GreedyLeastSquares">
<em class="property">class </em><code class="sig-prename descclassname">bfit.</code><code class="sig-name descname">GreedyLeastSquares</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span></em>, <em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">splitting_func</span><span class="o">=</span><span class="default_value">get_next_choices</span></em>, <em class="sig-param"><span class="n">factor</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="greedy/greedy_strat/index.html#bfit.greedy.greedy_strat.GreedyStrategy" title="bfit.greedy.greedy_strat.GreedyStrategy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bfit.greedy.greedy_strat.GreedyStrategy</span></code></a></p>
<dl class="py method">
<dt id="bfit.GreedyLeastSquares.density">
<em class="property">property </em><code class="sig-name descname">density</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares.density" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyLeastSquares.get_cost_function">
<code class="sig-name descname">get_cost_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares.get_cost_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyLeastSquares._solve_one_function_weight">
<code class="sig-name descname">_solve_one_function_weight</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">weight</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares._solve_one_function_weight" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyLeastSquares.get_best_one_function_solution">
<code class="sig-name descname">get_best_one_function_solution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares.get_best_one_function_solution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyLeastSquares.get_next_iter_params">
<code class="sig-name descname">get_next_iter_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares.get_next_iter_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyLeastSquares.get_optimization_routine">
<code class="sig-name descname">get_optimization_routine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares.get_optimization_routine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="bfit.GreedyLeastSquares.get_errors_from_model">
<code class="sig-name descname">get_errors_from_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#bfit.GreedyLeastSquares.get_errors_from_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, The QC-Devs Community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
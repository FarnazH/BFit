:py:mod:`bfit`
==============

.. py:module:: bfit

.. autoapi-nested-parse::

   
















   ..
       !! processed by numpydoc !!


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   greedy/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   _slater/index.rst
   density/index.rst
   fit/index.rst
   grid/index.rst
   measure/index.rst
   model/index.rst
   parse_ugbs/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   bfit.KLDivergenceSCF
   bfit.GaussianBasisFit
   bfit.ClenshawRadialGrid
   bfit.UniformRadialGrid
   bfit.CubicGrid
   bfit.AtomicGaussianDensity
   bfit.MolecularGaussianDensity
   bfit.AtomicDensity
   bfit.KLDivergence
   bfit.SquaredDifference
   bfit.GreedyStrategy
   bfit.GreedyKL
   bfit.GreedyLeastSquares




.. py:class:: KLDivergenceSCF(grid, density, model, mask_value=0.0, integration_val=None)

   Bases: :py:obj:`_BaseFit`

   
   Kullback-Leiber Divergence Self-Consistent Fitting.

   Optimizes the coefficients and exponents of the Gaussian Model to a function using the
   Kullback-Leibler divergence measure with the constraint that it is normalized.

   .. attribute:: grid

      Grid class that contains the grid points and integration methods on them.

      :type: (_BaseRadialGrid, CubicGrid)

   .. attribute:: density

      The true function evaluated on the grid points from `grid`.

      :type: ndarray(N,)

   .. attribute:: model

      The Gaussian basis model density. Located in `model.py`.

      :type: (AtomicGaussianDensity, MolecularGaussianDensity)

   .. attribute:: measure

      The deviation measure between true density and model density. Located in `measure.py`

      :type: (SquaredDifference, KLDivergence)

   .. attribute:: norm

      The integral of the attribute `density`.

      :type: float

   .. attribute:: lagrange_multiplier

      Lagrange multiplier.

      :type: float

   .. method:: run(): dict

      Runs the optimizing algorithm for optimizing coefficients and exponents to a linear
      combination of Gaussian functions.

   .. rubric:: Examples

   The goal is to fit a Gaussian density to some function.
   def f(x) :
       # Insert what it does here.
       return ...

   The first step is to define the grid object.
   >> grid = CubicGrid(0.01, 0.99, 0.01)

   Place the values of `f` on those grid points in an array.
   >> density = f(grid.points)

   Define the model, that you want to fit with.
   >> model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)

   Define which algorithm you want to optmize.
   >> fit = KLDivergenceSCF(grid, density, model)

   Optimize the coefficients and exponents but give an initial guess.
   >> initc = [1.] * 10
   >> inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
   >> result = fit.run(initc, inite)

   Print out the results.
   >> print("Optimized coefficients are: ", result["x"][0])
   >> print("Optimized exponents are: ", result["x"][1])
   >> print("Final performance measures are: ", result["performance"][-1])
   >> print("Was it successful? ", result["success"])

   .. rubric:: Notes

   - The algorithm uses masked value for floating point precision. This is due to the division found
   in the Kullback-Leibler formula. It is recommended to use `np.float64` or `np.float128` when
   storing the arrays. A higher Mask value will work as well but may cause poor precision.
   Alternatively, a well-chosen grid and/or initial guesses will avoid overflow/underflow
   floating-point issues.

   .. rubric:: References

   [1] BFit: Information-Theoretic Approach to Basis-Set Fitting of Electron Densities
           Alireza Tehrani, Farnaz Heidar-Zadeh, James S. M. Anderson, Toon Verstraelen, and
            TODO Add more authors if needed ... Paul W. Ayers.















   ..
       !! processed by numpydoc !!
   .. py:method:: lagrange_multiplier(self)
      :property:

      
      Obtain the lagrange multiplier.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _update_params(self, coeffs, expons, update_coeffs=True, update_expons=False)

      
      Compute updated coefficients & exponents of Gaussian basis functions.

      :param coeffs: The initial coefficients of Gaussian basis functions.
      :type coeffs: ndarray
      :param expons: The initial exponents of Gaussian basis functions.
      :type expons: ndarray
      :param update_coeffs: Whether to optimize coefficients of Gaussian basis functions.
      :type update_coeffs: bool, optional
      :param update_expons: Whether to optimize exponents of Gaussian basis functions.
      :type update_expons: bool, optional

      :returns: * **coeffs** (*ndarray*) -- The updated coefficients of Gaussian basis functions. Only returned if `deriv=True`.
                * **expons** (*ndarray*) -- The updated exponents of Gaussian basis functions. Only returned if `deriv=True`.















      ..
          !! processed by numpydoc !!

   .. py:method:: run(self, c0, e0, opt_coeffs=True, opt_expons=True, maxiter=500, c_threshold=1e-06, e_threshold=1e-06, d_threshold=1e-06, disp=False)

      
      Optimize the coefficients & exponents of Gaussian basis functions self-consistently.

      :param c0: The initial coefficients of Gaussian basis functions.
      :type c0: ndarray
      :param e0: The initial exponents of Gaussian basis functions.
      :type e0: ndarray
      :param opt_coeffs: Whether to optimize coefficients of Gaussian basis functions.
      :type opt_coeffs: bool, optional
      :param opt_expons: Whether to optimize exponents of Gaussian basis functions.
      :type opt_expons: bool, optional
      :param maxiter: Maximum number of iterations.
      :type maxiter: int, optional
      :param c_threshold: The convergence threshold for absolute change in coefficients. Default is 1e-6.
      :type c_threshold: float
      :param e_threshold: The convergence threshold for absolute change in exponents. Default is 1e-6.
      :type e_threshold: float
      :param d_threshold: The convergence threshold for absolute change in divergence value. Default is 1e-6.
      :type d_threshold: float
      :param disp: If true, then at each iteration the integral, :math:`L_1`, :math:`L_\infty` and
                   Kullback-Leibler measure is printed. Default is False.
      :type disp: bool

      :returns: **result** -- The optimization results presented as a dictionary containing:
                "x" : (ndarray, ndarray)
                    The optimized coefficients and exponents.
                "success": bool
                    Whether or not the optimization exited successfully.
                "fun" : ndarray
                    Values of KL divergence (objective function) at each iteration.
                "performance" : ndarray
                    Values of various performance measures of modeled density at each iteration,
                    as computed by `goodness_of_fit()` method.
                "time" : float
                    The time in seconds it took to complete the algorithm.
      :rtype: dict















      ..
          !! processed by numpydoc !!


.. py:class:: GaussianBasisFit(grid, density, model, measure='KL', method='SLSQP', weights=None, mask_value=1e-10)

   Bases: :py:obj:`_BaseFit`

   
   Optimizes either least-squares or Kullback-Leibler of Gaussian funcs using `Scipy.optimize`.

   The Gaussian functions can be constrained to have their integral be a fixed value.
       Although it is not recommended. The coefficients and exponents are always bounded to be
        positive.

   .. attribute:: grid

      Grid class that contains the grid points and integration methods on them.

      :type: (_BaseRadialGrid, CubicGrid)

   .. attribute:: density

      The true function evaluated on the grid points from `grid`.

      :type: ndarray(N,)

   .. attribute:: model

      The Gaussian basis model density. Located in `model.py`.

      :type: (AtomicGaussianDensity, MolecularGaussianDensity)

   .. attribute:: measure

      The deviation measure between true density and model density that is minimized.
      Can be either be "KL" (Kullback-Leibler, default) or "LS" (least-squares).

      :type: str, optional

   .. attribute:: norm

      The integration of the density over the grid.

      :type: float

   .. method:: run() :

   .. method:: func() :

   .. method:: evaluate_model() :

   .. rubric:: Examples

   The goal is to fit a Gaussian density to some function.
   def f(x) :
       # Insert what it does here.
       return ...

   The first step is to define the grid object.
   >> grid = CubicGrid(0.01, 0.99, 0.01)

   Place the values of `f` on those grid points in an array.
   >> density = f(grid.points)

   Define the model, that you want to fit with.
   >> model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)

   Define which measure (least-squares) and "scipy.optimize" algorithm to use.
   >> fit = GaussianBasisFit(grid, density, model, measure="LS", method="SLSQP")

   Optimize the coefficients and exponents but give an initial guess.
   >> initc = [1.] * 10
   >> inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
   >> result = fit.run(initc, inite)

   Print out the results.
   >> print("Optimized coefficients are: ", result["x"][0])
   >> print("Optimized exponents are: ", result["x"][1])
   >> print("Final performance measures are: ", result["performance"])
   >> print("Was it successful? ", result["success"])
   >> print("Why it terminated? ", result["message"])

   .. rubric:: Notes

   - The coefficients and exponents are bounded to be positive.

   - These methods in this class was found to be extremely hard to optimize. There appears
       to have many local minimas and Quasi-Newton methods seems inadequate in order to optimize
       these. Just the mere act of placing the initial guess to be close to the solution causes
       problems. It is highly recommended to have `with_constraint` to be False.

   - Note that the Kullback-Leibler between two functions f and g is positive if and only if
       the integrals of f and g are identical.  This constraint must be added for
       these optimizers.















   ..
       !! processed by numpydoc !!
   .. py:method:: run(self, c0, e0, opt_coeffs=True, opt_expons=True, maxiter=1000, tol=1e-14, disp=False, with_constraint=True)

      
      Optimize coefficients and/or exponents of Gaussian basis functions with constraint.

      :param c0: Initial guess for coefficients of Gaussian basis functions.
      :type c0: ndarray
      :param e0: Initial guess for exponents of Gaussian basis functions.
      :type e0: ndarray
      :param opt_coeffs: Whether to optimize coefficients of Gaussian basis functions.
      :type opt_coeffs: bool, optional
      :param opt_expons: Whether to optimize exponents of Gaussian basis functions.
      :type opt_expons: bool, optional
      :param maxiter: Maximum number of iterations.
      :type maxiter: int, optional
      :param tol: For slsqp. precision goal for the value of objective function in the stopping criterion.
                  For trust-constr, it is precision goal for the change in independent variables.
      :type tol: float, optional
      :param disp: If True, then it will print the convergence messages from the optimizer.
      :type disp: bool
      :param with_constraint: If true, then adds the constraint that the integration of the model density must
                              be equal to the constraint of true density. The default is True.
      :type with_constraint: bool

      :returns: **result** -- The optimization results presented as a dictionary containing:
                "x" : (ndarray, ndarray)
                    The optimized coefficients and exponents, respectively.
                "success": bool
                    Whether or not the optimization exited successfully.
                "message" : str
                    Message about the cause of termination.
                "fun" : float
                    Values of KL divergence (objective function) at the final iteration.
                "jacobian": ndarray
                    The Jacobian of the coefficients and exponents.
                "performance" : list
                    Values of various performance measures of modeled density at each iteration,
                    as computed by `_BaseFit.goodness_of_fit` method.
                "time" : float
                    The time in seconds it took to optimize.
      :rtype: dict

      .. rubric:: Notes

      - This is a constrained optimization such that the integration of the model density is
          a fixed value. Hence, only certain optimization algorithms can be used.
      - The coefficients and exponents are bounded to be positive.















      ..
          !! processed by numpydoc !!

   .. py:method:: func(self, x, *args)

      
      Compute objective function and its derivative w.r.t. Gaussian basis parameters.

      :param x: The parameters of Gaussian basis which is being optimized. Contains both the
                coefficients and exponents together in a 1-D array.
      :type x: ndarray
      :param args: Additional arguments to the model.

      :returns: The objective function value and its derivative wrt to coefficients and exponents.
      :rtype: float, ndarray















      ..
          !! processed by numpydoc !!

   .. py:method:: const_norm(self, x, *args)

      
      Compute deviation in normalization constraint.

      :param x: The parameters of Gaussian basis which is being optimized. Contains both the
                coefficients and exponents together in a 1-D array.
      :type x: ndarray
      :param args: Additional parameters for the model.

      :returns: The deviation of the integrla with the normalization constant.
      :rtype: float















      ..
          !! processed by numpydoc !!

   .. py:method:: evaluate_model(self, x, *args)

      
      Evaluate the model density & its derivative.

      :param x: The parameters of Gaussian basis which is being optimized. Contains both the
                coefficients and exponents together in a 1-D array.
      :type x: ndarray
      :param args: Additional parameters for the model.

      :returns: Evaluates the model density & its derivative.
      :rtype: float, ndarray















      ..
          !! processed by numpydoc !!


.. py:class:: ClenshawRadialGrid(atomic_number, num_core_pts, num_diffuse_pts, extra_pts=None, spherical=True)

   Bases: :py:obj:`_BaseRadialGrid`

   
   Clenshaw-Curtis Radial Grid Class.

   The Clenshaw-Curtis grid places more points closer to the origin of the interval :math:`[0, \inf).`
   It is defined as follows. Let :math:`Z, m, n` be the atomic number, number of points near origin,
   and the number of points far from the origin, respectively.

   Then each point :math:`r_p` of the Clenshaw radial grid is defined as:

   .. math::
       \begin{eqnarray}
           r_p = \frac{1}{2Z} \bigg(1 - \cos\bigg(\frac{\pi p}{400} \bigg)\bigg)  & p = 0, 1, \cdots, m - 1 \\
           r_p = 25 \bigg(1 - \cos\bigg(\frac{\pi p}{600} \bigg)\bigg) & p = 0, 1, \cdocts, n - 1\\
       \end{eqnarray}

   .. attribute:: points

      The radial grid points of a one-dimensional grid with N points.

      :type: ndarray, (N,)

   .. attribute:: atomic_number

      Return the atomic number.

   .. attribute:: spherical

      If true, then trapezoidal integration is done spherically (ie with a factor of :math:`4 \pi r^2`).

      :type: bool

   .. method:: integrate(arr)

      Integrate array `arr` defined over "point" array using trapezoidal integration.















   ..
       !! processed by numpydoc !!
   .. py:method:: atomic_number(self)
      :property:

      
      Return the atomic number.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _get_points(self, num_pts, mode='core')

      
      Generate radial points on [0, inf) based on Clenshaw-Curtis grid.

      The "core" points are concentrated near the origin based on:

      .. math:: r_p = 25 (1 - cos(\frac{\pi p}{2N})) for p =0,1..N-1

      The "diffuse" points are concentrated away from the origin based on:

      .. math:: r_p = \frac{1}[2Z} (1 - cos(\frac{\pi p}{2N})) for p=0,1...N-1,

      where :math:`Z` is the atomic number and :math:`N` is the number of points.

      :param num_pts: The number of points.
      :type num_pts: int
      :param mode: If "core", the points are placed closer to the origin. If "diffuse", the points are
                   placed far away from origin.
      :type mode: str, optional

      :returns: **points** -- The 1D array of grid points.
      :rtype: ndarray, (N,)















      ..
          !! processed by numpydoc !!


.. py:class:: UniformRadialGrid(num_pts, min_radii=0.0, max_radii=100.0, spherical=True)

   Bases: :py:obj:`_BaseRadialGrid`

   
   Uniformly Distributed Radial Grid Class.

   The grid points are equally-spaced in :math:`[0, max_points)` interval.

   .. attribute:: points

      The radial grid points of a one-dimensional grid with N points.

      :type: ndarray, (N,)

   .. attribute:: spherical

      If true, then trapezoidal integration is done spherically (ie with a factor of :math:`4 \pi r^2`).

      :type: bool

   .. method:: integrate(arr)

      Integrate array `arr` defined over "point" array using trapezoidal integration.















   ..
       !! processed by numpydoc !!

.. py:class:: CubicGrid(origin, axes, shape)

   
   Equally-Spaced 3D Cubic Grid Class.

   .. attribute:: points

      The three-dimensional array containing the `N` grid points that are uniform.

      :type: ndarray, (N, 3)

   .. attribute:: step

      The positive number representing the step-size of any two consequent grid points.

      :type: float

   .. method:: integrate(arr) :

      Integrate an array `arr` defined over the `points` using Riemannian sum.















   ..
       !! processed by numpydoc !!
   .. py:method:: axes(self)
      :property:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: from_molecule(cls, atcorenums, atcoords, spacing=0.2, extension=5.0, rotate=True)
      :classmethod:

      
      Construct a uniform grid given the molecular pseudo-numbers and coordinates.
      :param atcorenums: Pseudo-number of :math:`M` atoms in the molecule.
      :type atcorenums: np.ndarray, shape (M,)
      :param atcoords: Cartesian coordinates of :math:`M` atoms in the molecule.
      :type atcoords: np.ndarray, shape (M, 3)
      :param spacing: Increment between grid points along :math:`x`, :math:`y`, and :math:`z` direction.
      :type spacing: float, optional
      :param extension: The extension of the length of the cube on each side of the molecule.
      :type extension: float, optional
      :param rotate: When True, the molecule is rotated so the axes of the cube file are
                     aligned with the principle axes of rotation of the molecule.
                     If False, generates axes based on the x,y,z-axis and the spacing parameter, and
                     the origin is defined by the maximum/minimum of the atomic coordinates.
      :type rotate: bool, optional
















      ..
          !! processed by numpydoc !!

   .. py:method:: _calculate_volume(self, shape)

      
      Return the volume of the Uniform Grid.
















      ..
          !! processed by numpydoc !!

   .. py:method:: _choose_weight_scheme(self, shape)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: points(self)
      :property:

      
      Return cubic grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: __len__(self)

      
      Return the number of grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: integrate(self, arr)

      
      Compute the integral of a function evaluated on the grid points based on Riemann sums.

      .. math:: \int\int\int f(x, y, z) dx dy dz

      where :math:'f(r)' is the integrand.

      :param arr: The integrand evaluated on the grid points.
      :type arr: ndarray

      :returns: **value** -- The value of integral.
      :rtype: float















      ..
          !! processed by numpydoc !!


.. py:class:: AtomicGaussianDensity(points, center=None, num_s=1, num_p=0, normalize=False)

   
   Gaussian density model for modeling the electronic density of a single atom.

   Atomic Gaussian density is a linear combination of Gaussian functions of S-type
    and P-type functions:
   .. math::
       f(x) := \sum_i c_i e^{-\alpha_i |x - c|^2} + d_i |x - c|^2 e^{-\beta |x - c|^2}
   where
       :math:`c_i, d_i` are the coefficients of S-type and P-type functions.
       :math:`c` is the center of the Gaussian functions.
       :math:`x` is the real coordinates, can be multi-dimensional.

   .. attribute:: points

      The grid points, where N is the number of points and D is the dimension of a point.

      :type: ndarray(N, D)

   .. attribute:: radii

      Distance of points from the center :math:`c`.

      :type: ndarray(N, D)

   .. attribute:: num_s

      Number of S-type Gaussian basis functions.

      :type: int

   .. attribute:: num_p

      Number of P-type Gaussian basis functions.

      :type: int

   .. attribute:: nbasis

      Total number of basis functions (including S-type and P-type Gaussians).

      :type: int

   .. attribute:: natoms

      Number of atom or number of centers for Gaussian function.

      :type: int

   .. method:: evaluate(deriv='False') :

      Return Gaussian density function on `radii` by providing coefficients and exponents.
      If `deriv` is True, then derivative with respect to the coefficient and exponent is
      also returned.

   .. rubric:: Examples

   First define a grid.
   >> point = [-0.5, -0.25, 0., 0.25, 0.5]

   Define the center.
   >> center = np.array([-1.])

   Define the Model using 5 S-Type and P-type.
   >> model = AtomicGaussianDensity(point, center=center, num_s=5, num_p=5)

   Put first 5 coefficients of S-type followed by P-type. Same with exponents.
   >> coeff = np.array([1., 2., 3., 4., 5., 1., 2., 3., 4., 5.])
   >> exps = np.array([0.05, 0.1, 0.2, 0.3, 0.4, 0.01, 0.02, 0.03, 0.04, 0.05])
   >> model.evaluate(coeff, exps)















   ..
       !! processed by numpydoc !!
   .. py:method:: points(self)
      :property:

      
      Return the grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: radii(self)
      :property:

      
      Return the distance of grid points from center of Gaussian(s).
















      ..
          !! processed by numpydoc !!

   .. py:method:: num_s(self)
      :property:

      
      Return the number of s-type Gaussian basis functions.
















      ..
          !! processed by numpydoc !!

   .. py:method:: num_p(self)
      :property:

      
      Return the number of p-type Gaussian basis functions.
















      ..
          !! processed by numpydoc !!

   .. py:method:: nbasis(self)
      :property:

      
      Return the total number of Gaussian basis functions.
















      ..
          !! processed by numpydoc !!

   .. py:method:: natoms(self)
      :property:

      
      Return the number of basis functions centers.
















      ..
          !! processed by numpydoc !!

   .. py:method:: prefactor(self)
      :property:

      
      Obtain list of exponents for the prefactors.
















      ..
          !! processed by numpydoc !!

   .. py:method:: evaluate(self, coeffs, expons, deriv=False)

      
      Compute linear combination of Gaussian basis & its derivatives on the grid points.

      .. math::
          f(x) := \sum_i c_i e^{-\alpha_i |x - c|^2} + d_i |x - c|^2 e^{-\beta |x-c|^2}

      where
          :math:`c_i, d_i` are the coefficients of S-type and P-type functions.
          :math:`c` is the center of the Gaussian functions.
          :math:`x` is the real coordinates, can be multi-dimensional.

      :param coeffs: The coefficients of `num_s` s-type Gaussian basis functions followed by the
                     coefficients of `num_p` p-type Gaussian basis functions.
      :type coeffs: ndarray, (`nbasis`,)
      :param expons: The exponents of `num_s` s-type Gaussian basis functions followed by the
                     exponents of `num_p` p-type Gaussian basis functions.
      :type expons: ndarray, (`nbasis`,)
      :param deriv: Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &
                    exponents.
      :type deriv: bool, optional

      :returns: * **g** (*ndarray, (N,)*) -- The linear combination of Gaussian basis functions evaluated on the grid points.
                * **dg** (ndarray, (N, 2 * `nbasis`)) -- The derivative of a linear combination of Gaussian basis functions w.r.t. coefficients
                  & exponents, respectively, evaluated on the grid points. Only returned if `deriv=True`.















      ..
          !! processed by numpydoc !!

   .. py:method:: _eval_s(self, matrix, coeffs, expons, deriv)

      
      Compute linear combination of s-type Gaussian basis & its derivative on the grid points.

      :param matrix: The exp(-a * r**2) array evaluated on grid points for each exponent.
      :type matrix: ndarray, (N, M)
      :param coeffs: The coefficients of Gaussian basis functions.
      :type coeffs: ndarray, (M,)
      :param expons: The exponents of Gaussian basis functions.
      :type expons: ndarray, (M,)
      :param deriv: Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &
                    exponents.
      :type deriv: bool, optional

      :returns: * **g** (*ndarray, (N,)*) -- The linear combination of s-type Gaussian basis functions evaluated on the grid points.
                * **dg** (*ndarray, (N, 2*M)*) -- The derivative of linear combination of s-type Gaussian basis functions w.r.t.
                  coefficients (the 1st M columns) & exponents (the 2nd M columns) evaluated on the
                  grid points. Only returned if `deriv=True`.















      ..
          !! processed by numpydoc !!

   .. py:method:: _eval_p(self, matrix, coeffs, expons, deriv)

      
      Compute linear combination of P-type Gaussian basis & its derivative on the grid points.

      :param matrix: The exp(-a * r**2) array evaluated on grid points for each exponent.
      :type matrix: ndarray, (N, M)
      :param coeffs: The coefficients of Gaussian basis functions.
      :type coeffs: ndarray, (M,)
      :param expons: The exponents of Gaussian basis functions.
      :type expons: ndarray, (M,)
      :param deriv: Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &
                    exponents.
      :type deriv: bool, optional

      :returns: * **g** (*ndarray, (N,)*) -- The linear combination of p-type Gaussian basis functions evaluated on the grid points.
                * **dg** (*ndarray, (N, 2*M)*) -- The derivative of linear combination of p-type Gaussian basis functions w.r.t.
                  coefficients (the 1st M columns) & exponents (the 2nd M columns) evaluated on the
                  grid points. Only returned if `deriv=True`.















      ..
          !! processed by numpydoc !!


.. py:class:: MolecularGaussianDensity(points, coords, basis, normalize=False)

   
   Molecular Atom-Centered Gaussian Density Model.

   The Molecular Gaussian Density model is based on multiple centers each associated with a
       Gaussian density model (S or P-type) of any dimension.

   .. math::
           f(x) := \sum_j \sum_{i =1}^{M_j} c_{ji} e^{-\alpha_{ji} |x - m_j|^2} +
                                            d_{ji} |x - m_j|^2 e^{-\beta_{ji} |x - m_j|^2}

       where
           :math:`c_{ji}, d_{ji}` are the ith coefficients of S-type and P-type functions of the
               jth center.
           :math:`\alpha_{ji}, \beta_{ji}` are the ith exponents of S-type and P-type functions of
               the jth center.
           :math:`M_j` is the total number of basis functions of the jth center.
           :math:`m_j` is the coordinate of the jth center.
           :math:`x` is the real coordinates of the point. It can be of any dimension.

   .. attribute:: points

      The grid points in a two-dimensional array, where N is the number of points.

      :type: (N, 3) ndarray

   .. attribute:: radii

      Distance of `points` from each center, where M is the number of centers.

      :type: (M, N) ndarray

   .. attribute:: num_s

      Number of S-type Gaussian basis functions.

      :type: int

   .. attribute:: num_p

      Number of P-type Gaussian basis functions.

      :type: int

   .. attribute:: nbasis

      Total number of basis functions (including S-type and P-type Gaussians).

      :type: int

   .. attribute:: natoms

      Number of atom or number of centers.

      :type: int

   .. method:: evaluate(deriv='False') :

      Return Gaussian density function on `radii` by providing coefficients and exponents.
      If `deriv` is True, then derivative with respect to the coefficient and exponent is
      also returned.















   ..
       !! processed by numpydoc !!
   .. py:method:: points(self)
      :property:

      
      Get grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: nbasis(self)
      :property:

      
      Get the total number of Gaussian basis functions.
















      ..
          !! processed by numpydoc !!

   .. py:method:: radii(self)
      :property:

      
      Get the distance of grid points from center of each basis function.
















      ..
          !! processed by numpydoc !!

   .. py:method:: natoms(self)
      :property:

      
      Get number of basis functions centers.
















      ..
          !! processed by numpydoc !!

   .. py:method:: prefactor(self)
      :property:

      
      Get the pre-factor of Gaussian basis functions to make it normalized.

      Only used if attribute `normalize` is true.















      ..
          !! processed by numpydoc !!

   .. py:method:: assign_basis_to_center(self, index)

      
      Assign the Gaussian basis function to the atomic center.

      :param index: The index of Gaussian basis function.
      :type index: int

      :returns: **index** -- The index of atomic center.
      :rtype: int















      ..
          !! processed by numpydoc !!

   .. py:method:: evaluate(self, coeffs, expons, deriv=False)

      
      Compute linear combination of Gaussian basis & its derivatives on the grid points.

      The Molecular Gaussian is defined to be:
      .. math::
          f(x) := \sum_j \sum_{i =1}^{M_j} c_{ji} e^{-\alpha_{ji} |x - m_j|^2} +
                                           d_{ji} |x - m_j|^2 e^{-\beta_{ji} |x - m_j|^2}

      where
          :math:`c_{ji}, d_{ji}` are the ith coefficients of S-type and P-type functions of the
              jth center.
          :math:`\alpha_{ji}, \beta_{ji}` are the ith exponents of S-type and P-type functions of
              the jth center.
          :math:`M_j` is the total number of basis functions of the jth center.
          :math:`m_j` is the coordinate of the jth center.
          :math:`x` is the real coordinates of the point.

      Its derivative with respect to exponent of a single Gaussian with center :math:`m_j` is:
      .. math::
          \frac{\partial f}{\partial \alpha_{ji}} = -e^{-\alpha_{ji} |x - m_j|^2}.

      :param coeffs: The coefficients of `num_s` s-type Gaussian basis functions followed by the
                     coefficients of `num_p` p-type Gaussian basis functions.
      :type coeffs: ndarray, (`nbasis`,)
      :param expons: The exponents of `num_s` s-type Gaussian basis functions followed by the
                     exponents of `num_p` p-type Gaussian basis functions.
      :type expons: ndarray, (`nbasis`,)
      :param deriv: Whether to compute derivative of Gaussian basis functions w.r.t. coefficients &
                    exponents.
      :type deriv: bool, optional

      :returns: * **g** (*ndarray, (N,)*) -- The linear combination of Gaussian basis functions evaluated on the grid points.
                * **dg** (ndarray, (N, `nbasis`)) -- The derivative of linear combination of Gaussian basis functions w.r.t. coefficients
                  & exponents, respectively, evaluated on the grid points. Only returned if `deriv=True`.















      ..
          !! processed by numpydoc !!


.. py:class:: AtomicDensity(element, anion=False, cation=False)

   
   Atomic Density Class.

   Reads and Parses information from the .slater file of a atom and stores it inside this class.
   It is then able to construct the (total, core and valence) electron density based
   on linear combination of orbitals where each orbital is a linear combination of
   Slater-type orbitals.
   Elements supported by default from "./bfit/data/examples/" range from Hydrogen to Xenon.

   .. attribute:: Attributes relating to the standard electron configuration.

   .. attribute:: energy

      Energy of that atom.

      :type: list

   .. attribute:: configuration

      Return the electron configuration of the element.

      :type: str

   .. attribute:: orbitals

      List of strings representing each of the orbitals in the electron configuration.
      For example, Beryllium has ["1S", "2S"] in its electron configuration.
      Ordered based on "S", "P", "D", etc.

      :type: list, (M,)

   .. attribute:: orbitals_occupation

      Returns the number of electrons in each of the orbitals in the electron configuration.
      e.g. Beryllium has two electrons in "1S" and two electrons in "2S".

      :type: ndarray, (M, 1)

   .. attribute:: Attributes relating to representing orbitals as linear combination of Slater-type orbitals.

   .. attribute:: orbital_energy

      Energy of each of the N Slater-type orbital.

      :type: list, (N, 1)

   .. attribute:: orbitals_cusp

      Cusp of each of the N Slater-type orbital. Same ordering as `orbitals`. Does not exist
      for Heavy atoms past Xenon.

      :type: list, (N, 1)

   .. attribute:: orbitals_basis

      Keys are the orbitals in the electron configuration. Each orbital has N Slater-type orbital
      attached to them.

      :type: dict

   .. attribute:: orbitals_exp

      Key is the orbital in the electron configuration and the item of that key is the Slater
       exponents attached
       to each N Slater-type orbital.

      :type: dict (str : ndarray(N, 1))

   .. attribute:: orbitals_coeff

      Key is the orbital in the electron configuration (e. 1S, 2S or 2P) and the item is the
      Slater coefficients attached to each of the N Slater-type orbital.

      :type: dict (str : ndarray(N, 1))

   .. attribute:: basis_numbers

      Key is orbital in electron configuration and the item is the basis number of each of
      the N Slater-type orbital. These are the principal quantum number to each Slater-type
      orbital.

      :type: dict (str : ndarray(N, 1))

   .. method:: atomic_density(mode="total") :

      Construct the atomic density from the linear combinations of slater-type orbitals.
      Can compute the total (default), core and valence atomic density.

   .. method:: lagrangian_kinetic_energy :

      Construct the Positive Definite Kinetic energy.

   .. rubric:: Examples

   Grab information about Beryllium.
   >> be =  AtomicDensity("be")

   Some of the attributes are the following.
   >> print(be.configuration) #  Should "1S(2)2S(2)".
   >> print(be.orbitals)  # ['1S', '2S'].
   >> print(be.orbitals_occupation) # [[2], [2]] Two electrons in each orbital.
   >> print(be.orbitals_cusp)  # [1.0001235, 0.9998774].

   The Slatar coefficients and exponents of the 1S orbital can be obtained as:
   >> print(be.orbital_coeff["1S"])
   >> print(be.orbitals_exp["1S"])

   The total, core and valence electron density can be obtained as:
   >> points = np.arange(0., 25., 0.01)
   >> total_density = be.atomic_density(points, "total")
   >> core_density = be.atomic_density(points, "core")
   >> valence_density = be.atomic_density(points, "valence")

   .. rubric:: References

   [1] "Analytical Hartree–Fock wave functions subject to cusp and asymptotic constraints:
       He to Xe, Li+ to Cs+, H− to I−" by T. Koga, K. Kanayama, S. Watanabe and A.J. Thakkar.















   ..
       !! processed by numpydoc !!
   .. py:method:: slater_orbital(exponent, number, points)
      :staticmethod:

      
      Compute the Slater-type orbitals on the given points.

      A Slater-type orbital is defined as:
      .. math::
          R(r) = N r^{n-1} e^{- C r)

      where,
          :math:`n` is the principal quantum number of that orbital.
          :math:`N` is the normalizing constant.
          :math:`r` is the radial point, distance to the origin.
          :math:`C` is the zeta exponent of that orbital.

      :param exponent: The zeta exponents of Slater orbitals.
      :type exponent: ndarray, (M, 1)
      :param number: The principle quantum numbers of Slater orbitals.
      :type number: ndarray, (M, 1)
      :param points: The radial grid points.
      :type points: ndarray, (N,)

      :returns: **slater** -- The Slater-type orbitals evaluated on the grid points.
      :rtype: ndarray, (N, M)

      .. seealso:: :meth:`The`, :meth:`The`















      ..
          !! processed by numpydoc !!

   .. py:method:: phi_matrix(self, points, deriv=False)

      
      Compute the linear combination of Slater-type atomic orbitals on the given points.

      Each row corresponds to a point on the grid, represented as :math:`r` and
       each column is represented as a linear combination of Slater-type atomic orbitals
       of the form:

      .. math::
          \sum c_i R(r, n_i, C_i)

      where,
          :math:`c_i` is the coefficient of the Slater-type orbital.
          :math:`C_i` is the zeta exponent attached to the Slater-type orbital.
          :math:`n_i` is the principal quantum number attached to the Slater-type orbital.
          :math:`R(r, n_i, C_i)` is the Slater-type orbital.
          i ranges from 0 to K-1 where K is the number of orbitals in electron configuration.

      :param points: The radial grid points.
      :type points: ndarray, (N,)
      :param deriv: If true, use the derivative of the slater-orbitals.
      :type deriv: bool

      :returns: **phi_matrix** -- The linear combination of Slater-type orbitals evaluated on the grid points, where K is
                the number of orbitals. The order is S orbitals, then P then D.
      :rtype: ndarray(N, K)

      .. rubric:: Notes

      - At r = 0, the derivative of slater-orbital is undefined and this function returns
          zero instead. See "derivative_slater_type_orbital".















      ..
          !! processed by numpydoc !!

   .. py:method:: atomic_density(self, points, mode='total')

      
      Compute atomic density on the given points.

      The total density is written as a linear combination of Slater-type orbital
      whose coefficients is the orbital occupation number of the electron configuration:
      .. math::
          \sum n_i |P(r, n_i, C_i)|^2

      where,
          :math:`n_i` is the number of electrons in orbital i.
          :math:`P(r, n_i, C_i)` is a linear combination of Slater-type orbitals evaluated
              on the point :math:`r`.

      For core and valence density, please see More Info below.

      :param points: The radial grid points.
      :type points: ndarray, (N,)
      :param mode: The type of atomic density, which can be "total", "valence" or "core".
      :type mode: str

      :returns: **dens** -- The atomic density on the grid points.
      :rtype: ndarray, (N,)

      .. rubric:: Notes

      The core density and valence density is respectively written as:
      .. math::
          \sum n_i (1 - e^{-|e_i - e_{homo}|^2}) |P(r, n_i, C_i)|
          \sum n_i e^{-|e_i - e_{homo}|^2}) |P(r, n_i. C_i)|

      where,
          :math:`e_i` is the energy of the orbital i.
          :math:`e_{homo}` is the energy of the highest occupying orbital.















      ..
          !! processed by numpydoc !!

   .. py:method:: derivative_slater_type_orbital(exponent, number, points)
      :staticmethod:

      
      Compute the derivative of Slater-type orbitals on the given points.

      A Slater-type orbital is defined as:
      .. math::
          \frac{d R(r)}{dr} = \bigg(\frac{n-1}{r} - C \bigg) N r^{n-1} e^{- C r),

      where,
          :math:`n` is the principal quantum number of that orbital.
          :math:`N` is the normalizing constant.
          :math:`r` is the radial point, distance to the origin.
          :math:`C` is the zeta exponent of that orbital.

      :param exponent: The zeta exponents of Slater orbitals.
      :type exponent: ndarray, (M, 1)
      :param number: The principle quantum numbers of Slater orbitals.
      :type number: ndarray, (M, 1)
      :param points: The radial grid points. If points contain zero, then it is undefined at those
                     points and set to zero.
      :type points: ndarray, (N,)

      :returns: **slater** -- The Slater-type orbitals evaluated on the grid points.
      :rtype: ndarray, (N, M)

      .. rubric:: Notes

      - At r = 0, the derivative is undefined and this function returns zero instead.

      .. rubric:: References

      See wikipedia page on "Slater-Type orbitals".















      ..
          !! processed by numpydoc !!

   .. py:method:: lagrangian_kinetic_energy(self, points)

      
      Positive definite or Lagrangian kinetic energy density.

      :param points: The radial grid points.
      :type points: ndarray,(N,)

      :returns: **energy** -- The kinetic energy on the grid points.
      :rtype: ndarray, (N,)















      ..
          !! processed by numpydoc !!

   .. py:method:: derivative_density(self, points)

      
      Return the derivative of the atomic density on a set of points.

      :param points: The radial grid points.
      :type points: ndarray,(N,)

      :returns: **deriv** -- The derivative of atomic density on the grid points.
      :rtype: ndarray, (N,)















      ..
          !! processed by numpydoc !!


.. py:class:: KLDivergence(density, mask_value=1e-12)

   
   Kullback-Leibler Divergence Class.

   This is defined as the integral:
   .. math::
       D(f, g) := \int_G f(x) \ln ( \frac{f(x)}{g(x)} ) dx
   where,
       :math:`f` is the true probability distribution,
       :math:`g` is the model probability distribution,
       :math:`G` is the grid.

   .. attribute:: density

      The true function (being approximated) evaluated on `N` points.

      :type: ndarray(N,)

   .. attribute:: mask_value

      Values of model density `g` that are less than `mask_value` are masked when used in division
       and then replaced with the value of 1 so that logarithm of one is zero.

      :type: float

   .. method:: evaluate(deriv=False)

      Return the integrand :math:`f(x) \ln(f(x)/g(x))` between model and true functions.
      Note that it does not integrate the model, and so it doesn't exactly return the
      Kullback-Leibler. If `deriv` is True, then the derivative with respect to model function
      is returned.

   .. rubric:: Notes

   - This class does not return the Kullback-Leibler but rather the integrand.
       One would need to integrate this to get the Least Squared.
   - It using masked values to handle overflow and underflow floating point precision issues. This
       is due to the division in the Kullback-Leibler formula between two probability
       distributions.















   ..
       !! processed by numpydoc !!
   .. py:method:: evaluate(self, model, deriv=False)

      
      Evaluate the integrand of Kullback-Leibler divergence b/w true & model.

      .. math ::
          D(f, g) := \int_G f(x) \ln ( \frac{f(x)}{g(x)} ) dx
      where,
          :math:`f` is the true probability distribution,
          :math:`g` is the model probability distribution,
          :math:`G` is the grid.

      If the model density is negative, then this function will return extremely large values,
      for optimization purposes.

      :param model: The model density evaluated on the grid points.
      :type model: ndarray, (N,)
      :param deriv: Whether to compute the derivative of divergence w.r.t. model density.
      :type deriv: bool, optional

      :returns: * **m** (*ndarray, (N,)*) -- The divergence between density & model on the grid points.
                * **dm** (*ndarray, (N,)*) -- The derivative of divergence w.r.t. model density evaluated on the grid points.
                  Only returned if `deriv=True`.

      .. rubric:: Notes

      - Values of Model density that are less than `mask_value` are masked when used in
          division and then replaced with the value of 1 so that logarithm of one is zero.















      ..
          !! processed by numpydoc !!


.. py:class:: SquaredDifference(density)

   
   Squared Difference Class for performing the Least-Squared method.

   Least-squared is the defined to be the integral of the squared difference between
    true and model functions:
   .. math::
       ||f - g|| = \int_G (f(x) - g(x))^2 dx
   where,
       :math:`f` is the true function,
       :math:`g` is the model function,
       :math:`G` is the grid.

   The term :math:`|f(x) - g(x)|^2` is called the Squared Difference between f and g on a point x.

   .. attribute:: density

      The true function (being approximated) evaluated on `N` points.

      :type: ndarray(N,)

   .. method:: evaluate(deriv=False)

      Return the squared difference between model and true functions. Note that it does not
      integrate the model but rather only computes f(x) - g(x). If `deriv` is True,
      then the derivative with respect to model function is returned.

   .. rubric:: Notes

   - This class does not return the Least-Squared but rather the squared difference.
       One would need to integrate this to get the Least Squared.















   ..
       !! processed by numpydoc !!
   .. py:method:: evaluate(self, model, deriv=False)

      
      Evaluate squared difference b/w density & model on the grid points.

      This is defined to be :math:`(f(x) - g(x))^2`.

      :param model: The model density evaluated on the grid points.
      :type model: ndarray, (N,)
      :param deriv: Whether to compute the derivative of squared difference w.r.t. model density.
      :type deriv: bool, optional

      :returns: * **m** (*ndarray, (N,)*) -- The squared difference between density & model on the grid points.
                * **dm** (*ndarray, (N,)*) -- The derivative of squared difference w.r.t. model density evaluated on the
                  grid points. Only returned if `deriv=True`.















      ..
          !! processed by numpydoc !!


.. py:class:: GreedyStrategy

   Bases: :py:obj:`object`

   
















   ..
       !! processed by numpydoc !!
   .. py:attribute:: __metaclass__
      

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_cost_function(self)
      :abstractmethod:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_best_one_function_solution(self)
      :abstractmethod:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_next_iter_params(self)
      :abstractmethod:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_optimization_routine(self, local=False, *args)
      :abstractmethod:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_errors_from_model(self, params)
      :abstractmethod:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: store_errors(self, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: _find_best_lparams(self, param_list)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: __call__(self, factor, max_numb_funcs=30, backward_elim_funcs=None, add_choice_funcs=None, ioutput=False)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: _final_exit_info(self, num_func, max_func, best_val, prev_gval, redum)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: GreedyKL(grid, density, norm, splitting_func=get_next_choices, eps_coeff=0.001, eps_exp=0.0001, factor=2)

   Bases: :py:obj:`bfit.greedy.greedy_strat.GreedyStrategy`

   
















   ..
       !! processed by numpydoc !!
   .. py:method:: density(self)
      :property:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: norm(self)
      :property:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: grid(self)
      :property:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_model(self, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_cost_function(self, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_best_one_function_solution(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_next_iter_params(self, factor, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_optimization_routine(self, params, local=False)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_errors_from_model(self, params)

      
















      ..
          !! processed by numpydoc !!


.. py:class:: GreedyLeastSquares(grid, density, splitting_func=get_next_choices, factor=2)

   Bases: :py:obj:`bfit.greedy.greedy_strat.GreedyStrategy`

   
















   ..
       !! processed by numpydoc !!
   .. py:method:: density(self)
      :property:

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_cost_function(self, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: _solve_one_function_weight(self, weight)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_best_one_function_solution(self)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_next_iter_params(self, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_optimization_routine(self, params)

      
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_errors_from_model(self, params)

      
















      ..
          !! processed by numpydoc !!



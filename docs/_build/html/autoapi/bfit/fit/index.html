

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bfit.fit &mdash; BFit  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> BFit
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BFit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.fit</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/autoapi/bfit/fit/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="module-bfit.fit">
<span id="bfit-fit"></span><h1><a class="reference internal" href="#module-bfit.fit" title="bfit.fit"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bfit.fit</span></code></a><a class="headerlink" href="#module-bfit.fit" title="Permalink to this headline">¶</a></h1>
<p>Fitting Algorithms Module.</p>
<p>Contains the optimization algorithms for fitting a linear combination of Gaussian functions.</p>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>KLDivergenceSCF : Optimizes coefficients and exponents using self-consistent method.
GaussianBasisFit : Optimizes coefficients and exponents using <cite>Scipy.optimize</cite> function.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<p>The goal is to fit a Gaussian density to some function.
def f(x) :</p>
<blockquote>
<div><p># Insert what it does here.
return …</p>
</div></blockquote>
<p>The first step is to define the grid object.
&gt;&gt; from bfit.grid import CubicGrid
&gt;&gt; grid = CubicGrid(0.01, 0.99, 0.01)</p>
<p>Place the values of <cite>f</cite> on those grid points in an array.
&gt;&gt; density = f(grid.points)</p>
<p>Define the model, that you want to fit with.
&gt;&gt; from bfit.model import AtomicGaussianDensity, MolecularGaussianDensity
&gt;&gt; model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)
&gt;&gt; # model = MolecularGaussianDensity(grid.points, np.array([[0., 0., 0.], [1., 1., 1.]]),</p>
<blockquote>
<div><p># np.array([[5, 5], [5, 5]]))</p>
</div></blockquote>
<p>Define which algorithm you want to optmize.
&gt;&gt; fit = KLDivergenceSCF(grid, density, model)</p>
<p>Optimize the coefficients and exponents but give an initial guess.
&gt;&gt; initc = [1.] * 10
&gt;&gt; inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
&gt;&gt; result = fit.run(initc, inite)</p>
<p>Print out the results.
&gt;&gt; print(“Optimized coefficients are: “, result[“x”][0])
&gt;&gt; print(“Optimized exponents are: “, result[“x”][1])
&gt;&gt; print(“Final performance measures are: “, result[“performance”][-1])
&gt;&gt; print(“Was it successful? “, result[“success”])</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>The algorithm uses masked value for floating point precision for KLDivergenceSCF.</dt><dd><p>This is due to the division found in the Kullback-Leibler formula. It is recommended to use
<cite>np.float64</cite> or <cite>np.float128</cite> when storing the arrays. A higher Mask value will work as well
but may cause poor precision. Alternatively, a well-chosen grid and/or initial guesses will
avoid overflow/underflow floating-point issues.</p>
</dd>
</dl>
</li>
</ul>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] BFit: Information-Theoretic Approach to Basis-Set Fitting of Electron Densities</dt><dd><dl class="simple">
<dt>Alireza Tehrani, Farnaz Heidar-Zadeh, James S. M. Anderson, Toon Verstraelen, and</dt><dd><p>TODO Add more authors if needed … Paul W. Ayers.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Classes<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#bfit.fit.KLDivergenceSCF" title="bfit.fit.KLDivergenceSCF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KLDivergenceSCF</span></code></a></p></td>
<td><p>Kullback-Leiber Divergence Self-Consistent Fitting.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#bfit.fit.GaussianBasisFit" title="bfit.fit.GaussianBasisFit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GaussianBasisFit</span></code></a></p></td>
<td><p>Optimizes either least-squares or Kullback-Leibler of Gaussian funcs using <cite>Scipy.optimize</cite>.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="bfit.fit.KLDivergenceSCF">
<em class="property">class </em><code class="sig-prename descclassname">bfit.fit.</code><code class="sig-name descname">KLDivergenceSCF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span></em>, <em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">mask_value</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">integration_val</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#KLDivergenceSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.KLDivergenceSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_BaseFit</span></code></p>
<p>Kullback-Leiber Divergence Self-Consistent Fitting.</p>
<p>Optimizes the coefficients and exponents of the Gaussian Model to a function using the
Kullback-Leibler divergence measure with the constraint that it is normalized.</p>
<dl class="py attribute">
<dt id="bfit.fit.KLDivergenceSCF.grid">
<code class="sig-name descname">grid</code><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid class that contains the grid points and integration methods on them.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(_BaseRadialGrid, <a class="reference internal" href="../grid/index.html#bfit.grid.CubicGrid" title="bfit.grid.CubicGrid">CubicGrid</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.KLDivergenceSCF.density">
<code class="sig-name descname">density</code><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The true function evaluated on the grid points from <cite>grid</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.KLDivergenceSCF.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The Gaussian basis model density. Located in <cite>model.py</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="../index.html#bfit.AtomicGaussianDensity" title="bfit.AtomicGaussianDensity">AtomicGaussianDensity</a>, <a class="reference internal" href="../index.html#bfit.MolecularGaussianDensity" title="bfit.MolecularGaussianDensity">MolecularGaussianDensity</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.KLDivergenceSCF.measure">
<code class="sig-name descname">measure</code><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>The deviation measure between true density and model density. Located in <cite>measure.py</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="../index.html#bfit.SquaredDifference" title="bfit.SquaredDifference">SquaredDifference</a>, <a class="reference internal" href="../index.html#bfit.KLDivergence" title="bfit.KLDivergence">KLDivergence</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.KLDivergenceSCF.norm">
<code class="sig-name descname">norm</code><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>The integral of the attribute <cite>density</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.KLDivergenceSCF.lagrange_multiplier">
<code class="sig-name descname">lagrange_multiplier</code><a class="reference internal" href="../../../_modules/bfit/fit.html#KLDivergenceSCF.lagrange_multiplier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.lagrange_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Lagrange multiplier.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">run(): dict</code></dt>
<dd><p>Runs the optimizing algorithm for optimizing coefficients and exponents to a linear
combination of Gaussian functions.</p>
</dd></dl>

<p class="rubric">Examples</p>
<p>The goal is to fit a Gaussian density to some function.
def f(x) :</p>
<blockquote>
<div><p># Insert what it does here.
return …</p>
</div></blockquote>
<p>The first step is to define the grid object.
&gt;&gt; grid = CubicGrid(0.01, 0.99, 0.01)</p>
<p>Place the values of <cite>f</cite> on those grid points in an array.
&gt;&gt; density = f(grid.points)</p>
<p>Define the model, that you want to fit with.
&gt;&gt; model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)</p>
<p>Define which algorithm you want to optmize.
&gt;&gt; fit = KLDivergenceSCF(grid, density, model)</p>
<p>Optimize the coefficients and exponents but give an initial guess.
&gt;&gt; initc = [1.] * 10
&gt;&gt; inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
&gt;&gt; result = fit.run(initc, inite)</p>
<p>Print out the results.
&gt;&gt; print(“Optimized coefficients are: “, result[“x”][0])
&gt;&gt; print(“Optimized exponents are: “, result[“x”][1])
&gt;&gt; print(“Final performance measures are: “, result[“performance”][-1])
&gt;&gt; print(“Was it successful? “, result[“success”])</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The algorithm uses masked value for floating point precision. This is due to the division found</p></li>
</ul>
<p>in the Kullback-Leibler formula. It is recommended to use <cite>np.float64</cite> or <cite>np.float128</cite> when
storing the arrays. A higher Mask value will work as well but may cause poor precision.
Alternatively, a well-chosen grid and/or initial guesses will avoid overflow/underflow
floating-point issues.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] BFit: Information-Theoretic Approach to Basis-Set Fitting of Electron Densities</dt><dd><dl class="simple">
<dt>Alireza Tehrani, Farnaz Heidar-Zadeh, James S. M. Anderson, Toon Verstraelen, and</dt><dd><p>TODO Add more authors if needed … Paul W. Ayers.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="id0">
<em class="property">property </em><code class="sig-name descname">lagrange_multiplier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#KLDivergenceSCF.lagrange_multiplier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the lagrange multiplier.</p>
</dd></dl>

<dl class="py method">
<dt id="bfit.fit.KLDivergenceSCF._update_params">
<code class="sig-name descname">_update_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">expons</span></em>, <em class="sig-param"><span class="n">update_coeffs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">update_expons</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#KLDivergenceSCF._update_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.KLDivergenceSCF._update_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute updated coefficients &amp; exponents of Gaussian basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coeffs</strong> (<em>ndarray</em>) – The initial coefficients of Gaussian basis functions.</p></li>
<li><p><strong>expons</strong> (<em>ndarray</em>) – The initial exponents of Gaussian basis functions.</p></li>
<li><p><strong>update_coeffs</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize coefficients of Gaussian basis functions.</p></li>
<li><p><strong>update_expons</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize exponents of Gaussian basis functions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>coeffs</strong> (<em>ndarray</em>) – The updated coefficients of Gaussian basis functions. Only returned if <cite>deriv=True</cite>.</p></li>
<li><p><strong>expons</strong> (<em>ndarray</em>) – The updated exponents of Gaussian basis functions. Only returned if <cite>deriv=True</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.fit.KLDivergenceSCF.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">c0</span></em>, <em class="sig-param"><span class="n">e0</span></em>, <em class="sig-param"><span class="n">opt_coeffs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">opt_expons</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">500</span></em>, <em class="sig-param"><span class="n">c_threshold</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">e_threshold</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">d_threshold</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#KLDivergenceSCF.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.KLDivergenceSCF.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the coefficients &amp; exponents of Gaussian basis functions self-consistently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c0</strong> (<em>ndarray</em>) – The initial coefficients of Gaussian basis functions.</p></li>
<li><p><strong>e0</strong> (<em>ndarray</em>) – The initial exponents of Gaussian basis functions.</p></li>
<li><p><strong>opt_coeffs</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize coefficients of Gaussian basis functions.</p></li>
<li><p><strong>opt_expons</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize exponents of Gaussian basis functions.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations.</p></li>
<li><p><strong>c_threshold</strong> (<em>float</em>) – The convergence threshold for absolute change in coefficients. Default is 1e-6.</p></li>
<li><p><strong>e_threshold</strong> (<em>float</em>) – The convergence threshold for absolute change in exponents. Default is 1e-6.</p></li>
<li><p><strong>d_threshold</strong> (<em>float</em>) – The convergence threshold for absolute change in divergence value. Default is 1e-6.</p></li>
<li><p><strong>disp</strong> (<em>bool</em>) – If true, then at each iteration the integral, <span class="math notranslate nohighlight">\(L_1\)</span>, <span class="math notranslate nohighlight">\(L_\infty\)</span> and
Kullback-Leibler measure is printed. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> – The optimization results presented as a dictionary containing:
“x” : (ndarray, ndarray)</p>
<blockquote>
<div><p>The optimized coefficients and exponents.</p>
</div></blockquote>
<dl class="simple">
<dt>”success”: bool</dt><dd><p>Whether or not the optimization exited successfully.</p>
</dd>
<dt>”fun”<span class="classifier">ndarray</span></dt><dd><p>Values of KL divergence (objective function) at each iteration.</p>
</dd>
<dt>”performance”<span class="classifier">ndarray</span></dt><dd><p>Values of various performance measures of modeled density at each iteration,
as computed by <cite>goodness_of_fit()</cite> method.</p>
</dd>
<dt>”time”<span class="classifier">float</span></dt><dd><p>The time in seconds it took to complete the algorithm.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="bfit.fit.GaussianBasisFit">
<em class="property">class </em><code class="sig-prename descclassname">bfit.fit.</code><code class="sig-name descname">GaussianBasisFit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">grid</span></em>, <em class="sig-param"><span class="n">density</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">'KL'</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'SLSQP'</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask_value</span><span class="o">=</span><span class="default_value">1e-10</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#GaussianBasisFit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.GaussianBasisFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_BaseFit</span></code></p>
<p>Optimizes either least-squares or Kullback-Leibler of Gaussian funcs using <cite>Scipy.optimize</cite>.</p>
<dl class="simple">
<dt>The Gaussian functions can be constrained to have their integral be a fixed value.</dt><dd><dl class="simple">
<dt>Although it is not recommended. The coefficients and exponents are always bounded to be</dt><dd><p>positive.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt id="bfit.fit.GaussianBasisFit.grid">
<code class="sig-name descname">grid</code><a class="headerlink" href="#bfit.fit.GaussianBasisFit.grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid class that contains the grid points and integration methods on them.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(_BaseRadialGrid, <a class="reference internal" href="../grid/index.html#bfit.grid.CubicGrid" title="bfit.grid.CubicGrid">CubicGrid</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.GaussianBasisFit.density">
<code class="sig-name descname">density</code><a class="headerlink" href="#bfit.fit.GaussianBasisFit.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The true function evaluated on the grid points from <cite>grid</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.GaussianBasisFit.model">
<code class="sig-name descname">model</code><a class="headerlink" href="#bfit.fit.GaussianBasisFit.model" title="Permalink to this definition">¶</a></dt>
<dd><p>The Gaussian basis model density. Located in <cite>model.py</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="../index.html#bfit.AtomicGaussianDensity" title="bfit.AtomicGaussianDensity">AtomicGaussianDensity</a>, <a class="reference internal" href="../index.html#bfit.MolecularGaussianDensity" title="bfit.MolecularGaussianDensity">MolecularGaussianDensity</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.GaussianBasisFit.measure">
<code class="sig-name descname">measure</code><a class="headerlink" href="#bfit.fit.GaussianBasisFit.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>The deviation measure between true density and model density that is minimized.
Can be either be “KL” (Kullback-Leibler, default) or “LS” (least-squares).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str, optional</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="bfit.fit.GaussianBasisFit.norm">
<code class="sig-name descname">norm</code><a class="headerlink" href="#bfit.fit.GaussianBasisFit.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>The integration of the density over the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">run() :</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">func() :</code></dt>
<dd></dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">evaluate_model() :</code></dt>
<dd></dd></dl>

<p class="rubric">Examples</p>
<p>The goal is to fit a Gaussian density to some function.
def f(x) :</p>
<blockquote>
<div><p># Insert what it does here.
return …</p>
</div></blockquote>
<p>The first step is to define the grid object.
&gt;&gt; grid = CubicGrid(0.01, 0.99, 0.01)</p>
<p>Place the values of <cite>f</cite> on those grid points in an array.
&gt;&gt; density = f(grid.points)</p>
<p>Define the model, that you want to fit with.
&gt;&gt; model = AtomicGaussianDensity(grid.points, num_s=5, num_p=5, normalize=True)</p>
<p>Define which measure (least-squares) and “scipy.optimize” algorithm to use.
&gt;&gt; fit = GaussianBasisFit(grid, density, model, measure=”LS”, method=”SLSQP”)</p>
<p>Optimize the coefficients and exponents but give an initial guess.
&gt;&gt; initc = [1.] * 10
&gt;&gt; inite = np.array([0.001, 0.01, 0.1, 1., 2., 5., 10., 50., 75., 100.])
&gt;&gt; result = fit.run(initc, inite)</p>
<p>Print out the results.
&gt;&gt; print(“Optimized coefficients are: “, result[“x”][0])
&gt;&gt; print(“Optimized exponents are: “, result[“x”][1])
&gt;&gt; print(“Final performance measures are: “, result[“performance”])
&gt;&gt; print(“Was it successful? “, result[“success”])
&gt;&gt; print(“Why it terminated? “, result[“message”])</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The coefficients and exponents are bounded to be positive.</p></li>
<li><dl class="simple">
<dt>These methods in this class was found to be extremely hard to optimize. There appears</dt><dd><p>to have many local minimas and Quasi-Newton methods seems inadequate in order to optimize
these. Just the mere act of placing the initial guess to be close to the solution causes
problems. It is highly recommended to have <cite>with_constraint</cite> to be False.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note that the Kullback-Leibler between two functions f and g is positive if and only if</dt><dd><p>the integrals of f and g are identical.  This constraint must be added for
these optimizers.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt id="bfit.fit.GaussianBasisFit.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">c0</span></em>, <em class="sig-param"><span class="n">e0</span></em>, <em class="sig-param"><span class="n">opt_coeffs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">opt_expons</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">maxiter</span><span class="o">=</span><span class="default_value">1000</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">1e-14</span></em>, <em class="sig-param"><span class="n">disp</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">with_constraint</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#GaussianBasisFit.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.GaussianBasisFit.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize coefficients and/or exponents of Gaussian basis functions with constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c0</strong> (<em>ndarray</em>) – Initial guess for coefficients of Gaussian basis functions.</p></li>
<li><p><strong>e0</strong> (<em>ndarray</em>) – Initial guess for exponents of Gaussian basis functions.</p></li>
<li><p><strong>opt_coeffs</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize coefficients of Gaussian basis functions.</p></li>
<li><p><strong>opt_expons</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to optimize exponents of Gaussian basis functions.</p></li>
<li><p><strong>maxiter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – For slsqp. precision goal for the value of objective function in the stopping criterion.
For trust-constr, it is precision goal for the change in independent variables.</p></li>
<li><p><strong>disp</strong> (<em>bool</em>) – If True, then it will print the convergence messages from the optimizer.</p></li>
<li><p><strong>with_constraint</strong> (<em>bool</em>) – If true, then adds the constraint that the integration of the model density must
be equal to the constraint of true density. The default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> – The optimization results presented as a dictionary containing:
“x” : (ndarray, ndarray)</p>
<blockquote>
<div><p>The optimized coefficients and exponents, respectively.</p>
</div></blockquote>
<dl class="simple">
<dt>”success”: bool</dt><dd><p>Whether or not the optimization exited successfully.</p>
</dd>
<dt>”message”<span class="classifier">str</span></dt><dd><p>Message about the cause of termination.</p>
</dd>
<dt>”fun”<span class="classifier">float</span></dt><dd><p>Values of KL divergence (objective function) at the final iteration.</p>
</dd>
<dt>”jacobian”: ndarray</dt><dd><p>The Jacobian of the coefficients and exponents.</p>
</dd>
<dt>”performance”<span class="classifier">list</span></dt><dd><p>Values of various performance measures of modeled density at each iteration,
as computed by <cite>_BaseFit.goodness_of_fit</cite> method.</p>
</dd>
<dt>”time”<span class="classifier">float</span></dt><dd><p>The time in seconds it took to optimize.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>This is a constrained optimization such that the integration of the model density is</dt><dd><p>a fixed value. Hence, only certain optimization algorithms can be used.</p>
</dd>
</dl>
</li>
<li><p>The coefficients and exponents are bounded to be positive.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="bfit.fit.GaussianBasisFit.func">
<code class="sig-name descname">func</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#GaussianBasisFit.func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.GaussianBasisFit.func" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute objective function and its derivative w.r.t. Gaussian basis parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The parameters of Gaussian basis which is being optimized. Contains both the
coefficients and exponents together in a 1-D array.</p></li>
<li><p><strong>args</strong> – Additional arguments to the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The objective function value and its derivative wrt to coefficients and exponents.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.fit.GaussianBasisFit.const_norm">
<code class="sig-name descname">const_norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#GaussianBasisFit.const_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.GaussianBasisFit.const_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute deviation in normalization constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The parameters of Gaussian basis which is being optimized. Contains both the
coefficients and exponents together in a 1-D array.</p></li>
<li><p><strong>args</strong> – Additional parameters for the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The deviation of the integrla with the normalization constant.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="bfit.fit.GaussianBasisFit.evaluate_model">
<code class="sig-name descname">evaluate_model</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/bfit/fit.html#GaussianBasisFit.evaluate_model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#bfit.fit.GaussianBasisFit.evaluate_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the model density &amp; its derivative.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – The parameters of Gaussian basis which is being optimized. Contains both the
coefficients and exponents together in a 1-D array.</p></li>
<li><p><strong>args</strong> – Additional parameters for the model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Evaluates the model density &amp; its derivative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float, ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, The QC-Devs Community

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>